<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS实现垂直水平居中]]></title>
    <url>%2F2018%2F04%2F16%2FCSS%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[行内元素1、text-align:center;height = line-height;2、Flex布局，设置父元素display:flex;justify-content:center;3、table-cell 块级元素知道宽高实现垂直水平居中(1) position:absolute + margin:auto原理：将元素设置成position:absolute，并且将left、top、bottom、right设置为0，margin设置为auto。此时元素就会自动侵占父元素剩余空间，并且上/下，左/右占比相当，实现垂直水平居中。1234567891011.test &#123; width: 200px; height: 200px; background: green; position:absolute; left:0; top: 0; bottom: 0; right: 0; margin: auto; &#125; (2) position:absolute + 负margin特点：由于不设置宽高margin无效，无法实现不知道宽高水平居中，但是兼容性很好。原理：将元素设置成position:absolute，并且将left和top设置成50%。此时元素的左上角为页面正中心，也就是说元素在页面正中心的右下方，偏移距离就是元素本身的宽/高。然后通过设置负的margin(绝对值为元素的宽/高的一半)，把元素“拉”回来，从而达到居中效果。12345678910.test &#123; width:200px; height: 200px; background:green; position: absolute; left:50%; top:50%; margin-left:-100px; margin-top:-100px; &#125; 块级元素不知道宽高实现垂直水平居中(同样适用于知道宽高的场景)(1) transform原理：与absolute + 负margin相同，但是由于margin在不定义height/width的情况下会失效，所以无法适用于不知道宽高的场景。兼容性不好(IE8+)123456789.test &#123; width: 200px; height: 200px; background: green; position:absolute; left:50%; /* 定位父级的50% */ top:50%; transform: translate(-50%,-50%); /*自己的50% */&#125; (2) 万能的flex特点：方便易用，兼容性不足注意flex方法是对父级元素设置display:flex1234567.test &#123; height:600px; display:flex; justify-content:center; align-items:center; /* 只要三句话就可以实现不定宽高水平垂直居中 */&#125; (3) table-cell特点：兼容性好，但是性能差，浏览器绘制时间长，不利于SEO1234567891011121314151617/*table-cell实现居中将父盒子设置为table-cell元素，设置text-align:center,vertical-align: middle;子盒子设置为inline-block元素*/.tableCell&#123; display: table;&#125;.tableCell .container&#123; display: table-cell; text-align: center; vertical-align: middle;&#125;.tableCell .innerBox&#123; display: inline-block;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[协议知识汇总]]></title>
    <url>%2F2018%2F04%2F11%2FTCP-UDP%2F</url>
    <content type="text"><![CDATA[TCP和UDP的区别1、TCP是面向连接的协议，UDP是无连接的协议2、TCP可靠，UDP不可靠3、TCP有序(主要通过消息包排序实现)，UDP无序4、TCP无界，UDP有界5、TCP有拥塞控制，UDP没有6、TCP较重量级且传输速率较慢;UDP较轻量级，传输速率较快。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP 1.0→1.1→2.0 & HTTPS]]></title>
    <url>%2F2018%2F04%2F03%2FHTTP-1-0-1-1-2-0-S%2F</url>
    <content type="text"><![CDATA[HTTP 1.0 → HTTP 1.1长连接HTTP 1.0需要使用keep-alive参数来告知服务器建立长连接，而HTTP 1.1默认支持长连接，减少了TCP连接次数，节约开销。 节约带宽HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端只有接收到100，才开始把请求body发到服务器。当服务器返回401的时候，客户端就可以不用发送请求body了，这样节约了带宽。 HOST域HTTP 1.1支持host域，服务端可以通过host域设置多个虚拟站点来共享一个ip和端口。 HTTP 1.1 → HTTP 2.0多路复用HTTP 2.0使用多路复用技术，使用一个TCP连接并发处理多个请求，不但节约了开销而且可处理请求的数量也比HTTP 1.1大了很多。 TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此使用一个连接可以大大提高数据传输效率。 头部压缩HTTP 1.1不支持header数据压缩，HTTP 2.0使用HPACK算法对header的数据进行压缩，使得数据传输更快。 服务器推送当我们对支持HTTP 2.0的服务器请求数据额时候，服务器会顺便把一些客户端需要的资源一起推送到服务器，这种方式适用于加载静态资源，节约带宽。 HTTPSHTTP的缺点 使用明文通信，内容可能会被窃听 不验证通信双方身份，有可能遭遇伪装 无法证明报文的完整性，内容可能遭到篡改 HTTPS = HTTP + TLS/SSL加密 + 认证 + 完整性保护 TLS/SSL内容加密 数字证书验明身份 MD5、SHA-1等散列值方法防止篡改 虽然TLS/SSL采用公开密钥这种非对称加密方式，但是HTTPS并不是全部使用非对称加密，而是使用混合加密方式，即：公开密钥(非对称加密)+共享密钥(非对称加密)因为公开密钥与共享密钥加密相比，其处理速度要慢很多。所以HTTPS冲锋利用了两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型链和继承]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[理解原型链如上图，是一个原型链的一部分。我们来通过这个图解释一下原型链:(以下obj代指所有对象，Origin代指对象的原型) 每个obj都有一个constructor，通过prototype指向它的Origin constructor可以通过new操作符生成一个obj 每个obj又都有一个___proto__指向它的Origin,obj是Origin的实例对象 而它的Origin本质也是对象，所以Origin也有__proto__属性指向Origin的Origin 层层向上,直到指向Object为止,而每个Origin又都有constructor和实例对象(obj),这样就构成了一条原型链 原型链引申出来的几个问题：Q1: 在原型链上Object再往上是什么?A: 由于Object已经到顶了，所以Object.prototype.__proto__ === null Q2: 哪种情况下proto和prototype的指向是同一个?A: 由于function也是对象，所以有constructor，而constructor本质也是function，所以:12var func = function()&#123;&#125;func.__proto__ === func.constructor.prototype // true Q3: 判断Array有哪几种方法?A: 除了Object.prototype.toString.call(o) === &#39;[object Array]&#39;这种万能方式以外，还有两种原型链方式：12a instanceOf Array // (true/false) 判断a对象的原型链中是否存在构造函数Arraya.constructor === Array // (true/false) 直接判断a对象的构造函数是不是Array 但是这两种方法有个缺陷：如果这个a对象是从别的页面获取的，比如ifram，那么会造成原型链断裂现象，可能导致数组检测出的结果是Object而不是Array。 扩展：new操作符的原理（1）创建一个新对象，其原型为构造函数的prototype（2）将构造函数的作用域赋给新对象（于是this指向这个新对象）（3）执行构造函数中的代码（为该对象添加属性）（4）返回新对象给实例我们可以试着模拟一下new运算符过程：1234567891011121314var _new(func) &#123; var o = Object.create(func.prototype); /* * 第一步也可以写成： * var o = &#123;&#125;; * o.__proto__ === func.prototype */ var k = func.call(o); if(typeof k === Object)&#123; return k; &#125; else &#123; return o; &#125;&#125; &lt;– 未完待续 –&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>前端-JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[当我们在浏览器中输入一个URL后，发生了什么？]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[写在开头：这篇文章被我归入博客性能优化类别，是因为我认为如果我们要优化网站性能、提升用户体验，首要目标就是要知道用户在本地请求并加载你的网页的过程中，到底发生了什么，在此基础上我们才能更好的优化网页。 图源：知乎-张秋怡 浏览器解析并查询缓存DNS查询 DNS查询顺序如下，若其中一步成功则直接跳到建立链接部分： 浏览器自身DNS 操作系统DNS 本地hosts文件 向域名服务器发送请求 建立链接 TCP三次握手(three-way handshaking) 发送方:SYN(synchronize) 接收方:SYN/ACK(acknowledgement),确认信息传达 发送方:ACK - 确认接收方在线可收消息，握手结束 Accept TCP三次握手的的好处在于：发送方可以确认接收方仍然在线，不会因为白发送而浪费资源。 发送HTTP请求 报文首部(GET /index.html HTTP/1.1) 方法 URL HTTP版本 空行(CR+LF) 报文主体 注意:1.HTTP是无连接、无状态的，即HTTP在传输完成后就会断开，并且下一次登录时不会记录上次的登录状态。从HTTP/1.1开始才支持持久连接，即通信一次以后连接不中断。 正常为请求一次响应一次:请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3若采用持久连接请求管线化方式：请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3 使用管线化的条件： 服务端需要支持管线化 只有GET和HEAD可以进行管线化，POST请求有所限制 管线化不会影响响应到来的顺序 2.关于CR(Carriage Return,回车)和LF(Line Feed,换行) Dos和Windows采用CR/LF表示下一行UNIX/Linux采用LF表示下一行MAC OS系统则采用CR表示下一行 服务器发送响应 报文首部(HTTP/1.1 200 OK) HTTP版本 响应状态码 状态码信息 空行(CR+LF) 报文主体 客户端收到页面，浏览器渲染页面执行以下过程： 解析HTML 根据DOCTYPE来确定文档类型(最常见的就是HTML5,注意如果是HTML4的话有严格和宽松模式之分) 构建DOM树(根据HTML构建类似于二叉树的结构树) 下载资源 CSS - 构建CSSOM树 js - 等下下载并执行后解析 构建渲染树根据DOM和CSSOM树渲染，不可见元素不被会渲染 浏览器布局渲染 布局 - 根据渲染树布局(layout) 绘制 - 通过GUI在屏幕上绘制每个点 扩展:repaint: repaint发生更改时，元素外观被改变，且在没有改变布局的情况下发生，如改变outline，visibility，background color，不会影响到dom结构 虽然在业务中我们无法避免repaint，但是我们也应尽量减少repaint：利用fragment来插入多个节点。 reflow: 与repaint区别就是他会影响dom的结构渲染，同时他会触发repaint，他会改变他本身与所有父辈元素 这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。 reflow常见情况： 增删改DOM节点 移动DOM的位置或是动画显示(所以尽量用canvas来做动画) 修改width、display等CSS样式 resize窗口或是滚动的时候 修改网页默认字体(不建议) 如：display:none会触发reflow和repaint，而visibility:hidden只会产生repaint]]></content>
      <categories>
        <category>前端</category>
        <category>前端-性能优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[详解CSS实现三栏布局的七种方法]]></title>
    <url>%2F2018%2F03%2F02%2FCSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局在前端开发中特别常见，即两端固定中间自适应。下面就来介绍一下常用的三栏布局开发方式。 例如：高度固定为200px，两边固定为200px，中间自适应，效果如图： (1)Float方法原理： 元素浮动后，脱离文档流。 左右栏分别浮动在窗口两边，中间块(处于文档流中)受左右浮动影响被卡在中间无法继续向左右伸展已达到自适应，最后按需设置中间块的margin值来改变快间间隙即可。 基于纯float实现的三栏布局需要将中间的内容放在HTML结构的最后，DOM结构为左-右-中，否则右侧会沉在中间内容的下侧 . 缺点： 由于DOM结构限制左-右-中，主要内容无法最先加载 高度中间高度超出且没有margin的情况下会出问题(文字环绕)：解决方案为创建BFC 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .left &#123; float: left; height: 200px; width: 200px; background-color: red; &#125; .right &#123; width: 200px; height: 200px; background-color: blue; float: right; &#125; .main &#123; margin-left: 220px; margin-right: 220px; height: 200px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (2)绝对定位 position:absolute原理： 绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序 优点: 方便快捷，主要内容可以优先加载。 缺点： 由于容器脱离了文档流，导致子元素必须脱离文档流 高度未知的情况下会出问题 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .main &#123; height: 200px; margin: 0 220px; background-color: green; &#125; .left &#123; position: absolute; width: 200px; height: 200px; left: 0; background-color: red; &#125; .right &#123; position: absolute; width: 200px; height: 200px; background-color: blue; right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (3)Flex布局在讲flex布局之前我们先要了解一下flex布局的一些重要参数 (1)flex-grow:属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 (2)flex-shrink:属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小(比例可通过属性数值调节)。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 (3)flex-basis:属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 (4)flex:flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 flex实现三栏布局代码：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: flex; &#125; .main &#123; flex: 1; margin: 0 20px; height: 200px; background-color: green; &#125; .left &#123; width: 200px; height: 200px; background-color: red; &#125; .right &#123; width: 200px; height: 200px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;!-- flex布局的DOM顺序要按照 左-中-右 排--&gt; &lt;div class="left"&gt; &lt;/div&gt; &lt;div class="main"&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (4)Table布局优点： 兼容性很好 缺点： 无法设置栏边距，左中右模块间无间隔 对SEO不够友好 当一个格高度增加，其余的格也会被动增加高度 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: table; width: 100%; &#125; .left, .main, .right &#123; display: table-cell; &#125; .left &#123; width: 200px; height: 200px; background-color: red; &#125; .main &#123; background-color: green; &#125; .right &#123; width: 200px; height: 200px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (5)grid布局优点： 简单方便 缺点： 兼容性不强。高度未知的情况下会出问题。 1234567891011121314151617181920212223242526272829&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: grid; width: 100%; grid-template-rows: 200px; grid-template-columns: 200px auto 200px; &#125; .left &#123; background-color: red; &#125; .main &#123; margin: 0 20px; background-color: green; &#125; .right &#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (6)圣杯布局123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; margin-left: 220px; /* 为左右栏腾出空间 */ margin-right: 220px; &#125; .main &#123; float: left; width: 100%; height: 200px; background-color: green; &#125; .left &#123; float: left; width: 200px; height: 200px; margin-left: -100%; position: relative; left: -220px; background-color: red; &#125; .right &#123; float: left; width: 200px; height: 200px; margin-left: -200px; position: relative; right: -220px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (0)DOM结构为中-左-右。.container设置margin-left和margin-right为左右栏腾出空间。 (1)中间部分需要根据浏览器宽度自适应，所以要用width:100%，这里设三栏均向左浮动，因为中间100%，左层和右层没有位置上去 (2)将左栏设置为margin-left:-100%后，发现left上去了。这是因为左栏已经在最左边了，向左移动时，由于左侧没空间了，只能往上挪。而向左挪100%就相当于移动了一个main的距离，相当于向上移。 (3)按第二步的方法，将右栏向左移动一个身位(即margin:-200px)，这时右栏来到了上方的最右边。 (4)但由于左右栏遮挡住了中间部分，于是采用相对定位方法，各自相对于自己把自己挪出去，得到最终结果。 (7)双飞翼布局圣杯布局实际看起来是复杂的后期维护性也不是很高，在淘宝UED的探讨下，出来了一种新的布局方式就是双飞翼布局，增加多一个div就可以不用相对布局了，只用到了浮动和负边距。和圣杯布局差异的地方已经被注释。 优点： 结构简单，易维护 缺点： 三栏之间难以插入空挡 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; /* margin-left: 220px; margin-right: 220px; */ &#125; .main &#123; float: left; width: 100%; height: 200px; background-color: green; &#125; .left &#123; float: left; width: 200px; height: 200px; margin-left: -100%; /* position: relative; left: -220px; */ background-color: red; &#125; .right &#123; float: left; width: 200px; height: 200px; margin-left: -200px; /* position: relative; right: -220px; */ background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="main"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;!-- 新增inner --&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[script的异步、并行加载与顺序执行]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%B9%B6%E8%A1%8C%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[首先，我们先来看一下&lt;script&gt;标签的特性： 当浏览器遇到(即内嵌)&lt;script&gt;标签时，当前浏览器无从获知Javascript是否会修改页面内容，因此，此时浏览器会停止处理页面，先执行Javascript代码，然后再继续解析和渲染页面。——《高性能Javascript》 常用做法所以，为了避免在页面渲染中，因为解析script脚本而阻塞CSS文件和&amp;ltbody&gt;标签的加载，才出现了文章开头提到的CSS文件放在head中，script放在body的最后这种最常见做法。 动态加载但是，上述做法仍旧有一些弊端。在老旧的浏览器中如(IE8以前的版本)，页面仍然是一个个加载而不是并行加载的，这大大影响了用户体验。 于是有了动态加载： 动态加载文件，即通过DOM，在任意地方创建并插入&lt;script&gt;标签:1234var script = document.createElement('script');script.type = 'text/javascript';script.src = 'file.js'document.getElementsByTagName('head')[0].appendChild(script); 这种方法的优点在于： 无论在何时启动下载，文件的下载和执行过程不会阻塞页面其他进程(包括脚本加载) 然而这种方法仍有缺陷： 脚本会在下载完成后立即执行，这意味着多个脚本间的运行顺序无法保证(除了FF和Opera) 针对这种情况有如下改进：1234567891011121314151617181920function loadScript(url,callback) &#123; var script = document.createElement('script'); script.type = "text/javascript"; if(script.readyState)&#123; //IE中不支持onload，支持onreadystatechange //IE script.onreadystatechange = function() &#123; if(script.readyState == "loaded"||script.readyState=="complete") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //其他浏览器 script.onload = function() &#123; callback(); &#125;; &#125; script.src = url; document.getElementsByTagName('head')[0].appendChild(script);&#125; 上述代码改进的地方在于增加了一个回调函数，该函数会在相应脚本被加载完以后调用。以实现顺序加载，写法如下(假设file2依赖于file1，file3独立)：12345loadScript('file1.js',function()&#123; loadScript('file2.js',function()&#123;&#125;);&#125;);loadScript('file3.js',function()&#123;&#125;); LABjs库但这种方法仍然不够好，因为他的顺序执行是通过阻塞脚本来实现的，这时一个新的库出现了——LABjs:1234567891011&lt;body&gt; &lt;!-- 页面其他内容 --&gt; &lt;script type="text/javascript" src="LABjs.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; &amp;LAB .script('file1.js') .script('file2.js') .script('file3.js'); &lt;/script&gt;&lt;/body&gt; 异步加载异步加载JS还有两种方式:defer和async,两种方法的使用方式都是直接在&lt;script&gt;标签中加入即可。共同之处在于两者都会在页面加载完后再按顺序加载，并且加载完后都会立即执行。不同之处在于：defer:执行的顺序和&lt;script&gt;加载开始顺序相同。123//即使script2比script1先加载完，执行的顺序也是script1 -&gt; script2&lt;script src="/script1.js" defer&gt;&lt;script src="/script2.js" defer&gt; async:执行的顺序和&lt;script&gt;加载完的顺序相同。123//谁先加载完谁执行&lt;script src="/script1.js" async&gt;&lt;script src="/script2.js" async&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>前端-性能优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[零散知识汇总]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[HTML标签 &lt;a&gt;中不能再嵌套&lt;a&gt; &lt;ul&gt;中嵌套&lt;li&gt;构成无序列表 Unorderlist &lt;ol&gt;中嵌套&lt;li&gt;构成有序列表 Orderlist &lt;dl&gt;标签定义一个描述列表，与&lt;dt&gt;(定义项目名字)和&lt;dd&gt;(描述项目)一起使用 用法：(&lt;dt&gt;和&lt;dd&gt;可为任意个)1234&lt;dl&gt; &lt;dt&gt;Firefox&lt;/dt&gt; &lt;dd&gt;A free, open source, cross-platform, graphical web browser&lt;/dd&gt;&lt;/dl&gt; HTML5中新的表单元素 datalist : 规定输入域的选项列表,类似于下拉框 123456789&lt;input list="browsers" id="myBrowser" name="myBrowser" /&gt;&lt;datalist id="browsers"&gt; &lt;option value="Chrome"&gt; &lt;option value="Firefox"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt; &lt;option value="Microsoft Edge"&gt;&lt;/datalist&gt; output : 用于不同类型的输出 12345&lt;form oninput="result.value=parseInt(a.value)+parseInt(b.value)"&gt; &lt;input type="range" name="b" value="50" /&gt; + &lt;input type="number" name="a" value="10" /&gt; = &lt;output name="result"&gt;60&lt;/output&gt;&lt;/form&gt; keygen : 用于验证用户，但是已移出标准 置换元素 置换元素：浏览器根据元素的标签内容，来决定元素具体显示的内容常见的置换元素有：&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt; 不可置换元素：内容直接表现给客户端（如浏览器）常见的不可置换元素有：&lt;label&gt;、&lt;a&gt; 等 CSSlink和@import的区别 (1) link属于HTML标签，而@import由CSS提供 (2) 页面加载时，link会同时被加载，而@import引用的CSS会等到页面加载完时再加载 (3) import的IE版本要求为&gt;IE5，而link无兼容问题 字体相关的CSS 12345678text-transform : capitalize 首字母大写text-transform : lowercase 小写text-transform : uppercase 大写font-weight : bold 粗体font-weight : bolder 更粗font-weight : lighter 细体font-style : italic 斜体 可继承的样式 可继承:font-size,font-weight,line-weight,color,cursor 不可继承的一般是会会改变盒子模型的:display,margin,border,padding,height等 如果不想要继承属性的话可以设置position: static,这样做还会导致top,left,right失效 JS获取CSSgetComputedStyle可以获取渲染结束后最终的样式 JavaScriptnull和undefined的异同相同点： 在if判断语句中，值默认为false差异： null转化为数字类型为0，而undefined转化为数字类型为NaN null是一个很特殊的对象，常见做法为作为参数传入 设置为null的变量或者对象会被内存收集器回收 快速数组去重且排序123let arr = [...new Set([1,5,6,7])].sort(function(a,b)&#123; return a&lt;b ? -1 : 1 //升序&#125;) 快速数组乱序123let temArr = [1,5,6,8].sort(function()&#123; return Math.radom() &gt; 0.5 ? -1 : 1;&#125;) 求数组最大最小值之差123function MaxMin(arr) &#123; return Array.isArray(arr) ? Math.max.apply(Math,arr) - Math.min.apply(Math,arr) : console.log('Error') ;&#125; 回文串判定(正序倒序相同)1234var isPalindromes = function(param) &#123; param = params.toString().toLowerCase().replace(/[\W_\s]/g,''); return param === param.split('').reverse().join('');&#125; JS考题123456789var a = &#123;&#125;, b = &#123;key:'b'&#125;, c = &#123;key:'c'&#125;;a[b] = 123;a[c] = 465;console.log(a[b]); // 输出456// 原因：在a中,b和c均为[object Object],所以a[b] = 123; a[c] = 456;相当于都是在给[object Object]字段赋值，于是456覆盖了123 判断数组123456789101112// 有缺陷的方法，只有声明在当前页面才有效var ary = [1,23,4];console.log(ary instanceof Array) //true;var ary = [1,23,4];console.log(ary.__proto__.constructor==Array); //trueconsole.log(ary.constructor==Array) //true 这两段代码是一样的// 通用的方法:Object原型的toString方法function isArray(o)&#123;return Object.prototype.toString.call(o)=='[object Array]';&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[细说localStorage, sessionStorage, Cookie, Session]]></title>
    <url>%2F2018%2F02%2F21%2F%E7%BB%86%E8%AF%B4localStorage-sessionStorage-Cookie-Session%2F</url>
    <content type="text"><![CDATA[localStorage和sessionStorage两者的共同点在于：1、存储大小均为5M左右2、都有同源策略限制3、仅在客户端中保存，不参与和服务器的通信 两者的不同点在于：1、生命周期 —— 数据可以存储多少时间 localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。 sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。 2、作用域 —— 谁拥有数据的访问权 localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。 sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。 为了更好的理解sessionStorage,我们来看个例子： 例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的iframe元素的话，这两个iframe的 sessionStorage 是可以互通的。 API123456//sessionStorage用法相同localStorage.setItem("name",1); // 以"x"为名字存储一个数值localStorage.getItem("name"); // 获取数值localStorage.key(i); // 获取第i对的名字localStorage.removeItem("name"); // 获取该对的值localStorage.clear(); // 全部删除 Cookie基本概念Cookie是小甜饼的意思，主要有以下特点： 1、顾名思义，Cookie 确实非常小，它的大小限制为4KB左右 2、主要用途是保存登录信息和标记用户(比如购物车)等，不过随着localStorage的出现，现在购物车的工作Cookie承担的较少了 3、一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 5、原生API不如storage友好，需要自己封装函数 用法(API)服务端向客户端发送的cookie(HTTP头,不带参数)：Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt; (name可选) 服务端向客户端发送的cookie(HTTP头，带参数)：Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2) 客户端设置cookie：1document.cookie = "&lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)" 可选参数： Expires=&lt;date&gt;：cookie的最长有效时间，若不设置则cookie生命期与会话期相同 Max-Age=&lt;non-zero-digit&gt;：cookie生成后失效的秒数 Domain=&lt;domain-value&gt;：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。 Path=&lt;path-value&gt;：指定一个URL，例如’path=/docs’，则’/docs’、’/docs/Web/‘、’/docs/Web/Http’均满足匹配条件 Secure：必须在请求使用SSL或HTTPS协议的时候cookie才会被发送到服务器 HttpOnly：客户端无法更改Cookie，客户端设置cookie时不能使用这个参数，一般是服务器端使用 示例：123Set-Cookie: sessionid=aes7a8; HttpOnly; Path=/document.cookie = &quot;KMKNKK=1234;Sercure&quot; 可选前缀：__Secure-：以__Secure-为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS） __Host-：以__Host-为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为’/‘。 前缀使用示例：12345Set-Cookie: __Secure-ID=123; Secure; Domain=example.comSet-Cookie: __Host-ID=123; Secure; Path=/document.cookie = &quot;__Secure-KMKNKK=1234;Sercure&quot;document.cookie = &quot;__Host-KMKNKK=1234;Sercure;path=/&quot; Session基本概念Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。 在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。 大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器 与Cookie的关系与区别：1、Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 2、Cookie的安全性一般，他人可通过分析存放在本地的Cookie并进行Cookie欺骗。在安全性第一的前提下，选择Session更优。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie就好了。 3、单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie。 4、当访问增多时，Session会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用Cookie。 5、Session的运行依赖Session ID，而Session ID是存在 Cookie 中的。也就是说，如果浏览器禁用了Cookie,Session也会失效（但是可以通过其它方式实现，比如在url中传递Session ID,即sid=xxxx）。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-性能优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2018%2F02%2F21%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器缓存缓存主要分为强缓存和协商缓存，使用方法为在HTTP请求/响应中加入头部信息。 使用场景为：1、浏览器需要资源A，当浏览器需要这个资源时会先检测本地是否有该资源的缓存2、如果没有缓存则向服务器发出请求，服务器下发一个强缓存3、如果有缓存，则检测缓存是否过期，如果没过期则直接使用，如果过期了则进行协商缓存 强缓存Expires: Expires:Thu,21 Jan 2017 23:23:23 GMT服务器下发的资源绝对过期时间 Cache-Control: Cache-Control:max-age=3600由于客户端和服务器时间可能存在偏差，于是出现了这种方法。原理为规定相对于系统时间的一段时间，单位为秒，表示在客户端在收到资源3600秒后资源失效 当Expires和Cache-Control同时存在时，以Cache-Control为准 协商缓存Last-Modified If-Modidied-Since : Last-Modified:Wed,26 Jan 2017 17:17:17 GMT客户端发送本地文件上次更新的时间，与服务器文件上次更新的时间作比较，如果不同则更新资源。 Etag If-None-Match:上述方法有一个缺点: 有可能资源内容没更新，但是文件被修改了，这就导致了没必要的浪费，于是出现了Etag字段也是使用客户端和服务端的文件信息比较，只不过这是比较类似于Hash的值，通过这种方法可以判断文件资源是否发生改变。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-性能优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[页面性能优化方式总结]]></title>
    <url>%2F2018%2F02%2F20%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文主要是总结一下页面性能优化的主要方式。 1、资源压缩合并、减少HTTP请求2、非核心代码异步加载3、利用浏览器缓存4、使用CDN5、预解析DNS12&lt;meta http-equiv="x-dns-prefetch-control" content="on"&gt;&lt;link rel="dns-prefetch" href="//prefetch.com"&gt; 6、错误监控 前端错误分类即时运行错误(1)try..catch (2)window.onerror ：只能捕获即时运行错误，不能捕获资源加载错误 资源加载错误(1)object.onerror ：资源文件出错时会触发object.onerror，但不会向上冒泡触发window.onerror(2)performance.getEntries() ：获取成功加载的资源文件，使用全部文件减去没加载的就是加载出错的文件(3)Error事件捕获 ：注意是捕获不是冒泡，参数为true123window.addEventListener('error',function(e)&#123; console.log('捕获', e);&#125;,true); 跨域时的JS运行错误1、在script标签上增加crossorigin属性2、设置js资源响应头Access-Control-Allow-Origin:*|域名 错误上报利用image对象上报错误1(new Image()).src = "路径"; //一行代码即可实现资源上报]]></content>
      <categories>
        <category>前端</category>
        <category>前端-性能优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git一些小tips]]></title>
    <url>%2F2018%2F02%2F18%2Fgit%2F</url>
    <content type="text"><![CDATA[最近在和好基友用Github练习共同开发，期间发现了一些问题和一些有用的Tips，在这里挑一些比较有有用/有意思的小小总结一下。 问题:起初没啥经验，.gitignore总是空空白白的，导致Git的文件过于冗余。 并且很致命的一点是这会导致上传一些没必要的配置文件，而由于电脑环境变量或者轮子版本的不同，很可能会导致编译错误= =解决方法：丰富.gitignore 文件，遵守Github规范1234567891011121314151617181920212223242526272829303132333435363738394041# See http://help.github.com/ignore-files/ for more about ignoring files.# compiled output/dist/tmp# dependencies/node_modules# IDEs and editors/.idea.project.classpath.c9/*.launch.settings/*.sublime-workspace# IDE - VSCode.vscode/*!.vscode/settings.json!.vscode/tasks.json!.vscode/launch.json!.vscode/extensions.json# misc/.sass-cache/connect.lock/coverage/*/libpeerconnection.lognpm-debug.logtestem.log/typings# e2e/e2e/*.js/e2e/*.map#System Files.DS_StoreThumbs.db 小Tips：在提交到Github的时候，我们需要写一些信息来介绍一下这次提交。不仅是提醒自己，同样也使得其他开发者和用户能够更清楚地了解项目动向。所以一个清晰地Summary就显得比较重要了。 在这里介绍一种增加Summary可读性的方法：加入emoji 这不仅使得commit的Summary更加美观、具有可读性，而且在遵循emoji使用规范的前提下，能使得读者更易了解commit的内容。 效果如图： 以下为常用emoji使用规范，查看完整文档。]]></content>
      <categories>
        <category>Git/Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同源策略及前后端(同源/跨域)通信]]></title>
    <url>%2F2018%2F02%2F12%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[什么是同源策略和限制？源：= 协议 + 域名 + 端口 同源策略：在MDN中有如下解释:同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 限制：当源不一样时，就产生了跨域。不是一个源的文档没有权利去操作另一个源的文档。具体表现为： Cookie、LocalStorage、IndexDB 无法读取 DOM 无法获得 AJAX请求无法发送 前后端如何通信？ AJAX(同源) WebSocket(不受同源策略限制) CORS(支持跨域也支持同源通信) 如何创建Ajax XMLHttpRequest 兼容性处理 : windows下为window.ActiveXObject(&#39;Microsoft.XMLHTTP&#39;) 事件触发条件123456789101112131415161718// Ajax实现var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject('Microsoft.XMLHTTP');xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;xhr.open("get", "example.txt", true);// 如何设置请求头? xhr.setRequestHeader(header, value);xhr.setRequestHeader('Content-Type', 'application/json');xhr.send(null); 跨域通信的几种方式 JSONP(1)动态创建一个&lt;script&gt;标签，发送给服务端一个包含回调名callback，并且在本地创建一个与回调名相同的全局函数(2)服务端返回数据(3)浏览器将返回的数据当成js来执行 123456789101112131415161718192021222324252627// jsonp实现function jsonp(url,func) &#123; var _script = document.createElement("script"); if(url.indexOf("?") === -1)&#123; script.src = url+"?callback="+func; &#125; else &#123; script.src = url+"&amp;callback="+func; &#125; document.body.insertBefore(_script,document.body.firstChild); script.onload = script.onreadystatechange = function() &#123; // onload delete _script; script.parentNode.removeChild(_script); &#125; script.onerror = function() &#123; // onerror delete _script; script.parentNode.removeChild(_script); &#125;&#125; function result(res) &#123; console.log(res.name);&#125; postMessage:H5中新增的标准,主要用于iframe 123456789//窗口A(http:A.com)向跨域的窗口B(http://B.com)发送消息//A窗口中B窗口对象.postMessage('data','http://B.com');//在窗口B中监听window.addEventListener('message',function(event) &#123; console.log(event.origin); // http://A.com console.log(event.sourcr); // Awindow console.log(event.data); // data&#125;,false); Hash:页面不刷新也能获取新资源,主要用于iframe 12345678// 使用场景：当前页面A通过iframe嵌入了跨域的页面B// A中伪代码如下var B = document.getElementsByTagName('iframe');B.src = B.src + '#' + 'data';// B中伪代码如下window.onhashchange = function() &#123; var data = window.location.hash;&#125; nginx反向代理:主要使用了nginx.conf内的proxy_pass http://xxx.xxx.xxx,将所有请求代理到该域名，有利有弊。 WebSocket:全双工通信方式主要原理是：基于HTTP向服务端发送WebSocket请求，服务端许可后返回101，客户端收到101，将协议换成WebSocket，建立连接。 CORS:可以理解为支持跨域通信的AJAX主要原理是：浏览器发现了有跨域的AJAX请求，就会自动添加一些附加的头部信息(一般为Origin)后发送给服务端，如果服务端允许CORS，则返回Access-Control-Allow-Credentials字段以及其他可选字段，如果没有该字段则说明出错。完整原理：阮一峰博客]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[理解HTML标签语义化]]></title>
    <url>%2F2018%2F02%2F06%2FHTML%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是标签语义化标签的语义通过标签判断内容语义，例如根据&lt;h1&gt;标签我们呢能够判断出该内容是标题，根据&lt;p&gt;标签判断出该内容是段落，根据&lt;input&gt;标签判断出该内容是输入框等 如何判断一个网页是否遵循标签语义化去掉网页样式，看该网页的结构是否良好有序，是否仍有很好的可读性 为什么标签要语义化？12341. 标签语义化对于搜索引擎友好，利于SEO2. 更容易让屏幕阅读器读出网页内容3. 去掉或者丢失样式的时候，页面仍然能够呈现清晰的结构4. 便于团队的开发与维护 如何使标签更具语义化 对于不同的内容使用对应的标签，如段落使用&lt;p&gt;标签，锚点使用&lt;a&gt;标签 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 用title、alt用于解释名词或解释图片信息，活用label标签 通过为&lt;input&gt;设置id属性，在&lt;label&gt;标签中设置”for = id”来让文本和相应的&lt;input&gt;对应起来 尽可能地减少使用无语义的标签如&lt;div&gt;和&lt;span&gt; 语意不明显，可以用&lt;p&gt;也可以用&lt;div&gt;的情况下，尽量用&lt;p&gt;，因为&lt;p&gt;在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，改用CSS设置 使用HTML5结构元素，如&lt;head&gt;、&lt;footer&gt;等，参考文章：HTML 5的革新——语义化标签]]></content>
      <categories>
        <category>前端</category>
        <category>前端-HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IM即时聊天室（三）：项目详解及源码分析]]></title>
    <url>%2F2018%2F02%2F02%2FIM%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[之前我们在 IM即时聊天室（一）：WebSocket 和 IM即时聊天室（二）: Socket.io + Node.js 两篇文章中介绍了搭建一个IM的所需的技术栈和通信原理。那在这篇文章里我们就来详细说一下具体的应用并提供完整源码。 聊天室在线地址：点此进入 PS: 这是我网络编程课的一个小作业，因为博主比较懒所以这篇文章的大部分由我的课程报告组成（逃） 实现目标应用实例是一个多人聊天室程序，用户可以通过指定服务器IP进入聊天室和聊天室内其他用户进行聊天，聊天室的功能主要有文本、表情和图片传输，并在Web界面中显示。 需求分析 应用采用客户/服务器模式，分为客户端程序和服务器端程序。 用户通过客户端可以选择头像，发送信息、表情、图片 服务端可以同时接收多个客户端信息，并根据需求进行转发、广播或者回传给客户端特定的消息。 客户端程序和服务器程序通过网络交换聊天的字符串内容（其中表情和头像为特殊格式代码，图片为转码后获得的URL格式） 话不多说，先看程序效果展示： 技术实现(1)通信协议选择Balabalabala… 详见下面两篇文章IM即时聊天室（一）：WebSocketIM即时聊天室（二）：Socket.io + Node.js (2)客户端 UI界面：HTML+CSS+Bootstrap自适应 界面交互：原生Javascript+jQuery 消息的发送和接收：Socket.io PS：由于客户端代码太太太太太多了，我只挑比较有特点的的讲一下 登录啥的就不讲了，大概思路就是开始时隐藏聊天界面，登录成功后隐藏登录界面显出聊天界面，源码里有完整的注释 先贴一下客户端代码大致结构图： 比较有意思的代码是我仿照微信做了一个回到最新消息处的功能。 当我们在聊天时，我们会希望最新的消息实时显示出来，但是当我们在看历史消息时，可不希望被强行定位到最新消息处。并且在查看历史消息时，可以通过按钮回到最新消息处。 于是我们就要判断用户在查看历史消息还是正在聊天，方法就是判断最新的消息是否出现在了用户窗口里。 关键代码： 123456789101112131415161718192021222324252627282930313233/*将页面下拉到最新消息处*/ function scrollToEnd()&#123; var div = document.getElementsByTagName(&quot;div&quot;); div_length = div.length-4; div[div_length].scrollIntoView(&#123;behavior: &quot;smooth&quot;&#125;); //平滑滚动，提高了用户体验 &#125; /*判断当有新信息来时，用户是否在页面底端*/ function isNewInWindow()&#123; var div = document.getElementsByTagName(&quot;div&quot;); div_length = div.length-5; if(isInWindow(div[div_length]))&#123; return true; &#125; return false; &#125; /*判定元素是否在界面内*/ function isInWindow(x)&#123; if(x.getBoundingClientRect().top &gt; window.innerHeight)&#123; console.log(&quot;down&quot;); return false; &#125; else if(x.getBoundingClientRect().bottom &lt; 0)&#123; console.log(&quot;up&quot;); return false; &#125; return true; &#125; (3)服务端服务端主要使用了Node.js+Socket.io来构建服务端，需要Node环境来运行。 主要的思路：请求HTTP服务 → 在此基础上使用WebSocket → 引入Socket.io模块并创建实例 → 用该实例进行socket监听 → 通过socket进行消息的发送、转发、群发等。 服务端关键代码： 12345678910var app = require(&apos;http&apos;).createServer();var io = require(&apos;socket.io&apos;)(app);var PORT = 8081;/*定义用户数组*/var users = [];app.listen(PORT);io.on(&apos;connection&apos;,function (socket) &#123; //监听 //发送、转发、群发消息&#125;) (4)图片文件传输 图片传输部分我本来是想用Base64编码，先在客户端读取图片二进制信息并编成Base64格式发送给服务端，服务端转发后别的客户端接收后解码。 但是后面放弃了这一方式，因为直接传输二进制信息太慢了，于是改用了HTML5的Filereader方法。 这个方法有个优点就是其中的readAsDataURL函数可以直接将图片二进制信息转成URL格式，这样子我只用发送并转发一个简短的URL，客户端直接根据URL加载图片，省去了大量传输和解码时间。 关键代码： 1234567891011121314151617181920212223//图片发送document.getElementById(&apos;sendImage&apos;).addEventListener(&apos;change&apos;, function() &#123; //检查是否有文件被选中 if (this.files.length != 0) &#123; //获取文件并用FileReader进行读取 var file = this.files[0], reader = new FileReader(); if (!reader) return; reader.onload = function(e) &#123; //读取成功，发送到服务器 socket.emit(&apos;sendImg&apos;,&#123; username:uname, image: e.target.result, date:new Date().toTimeString().substr(0, 8),headnum:headnum &#125;); &#125;; reader.readAsDataURL(file); &#125;;&#125;, false); (5)头像选择/表情包传输头像和表情已经预先放置在客户端中，用户在选择以后将产生特定格式的代码，放置到要发送的信息当中。 别的客户端接收到的消息时候，先用正则表达式检索信息中是否存在该格式代码，若有则加载相应的头像/表情，以达到效果。 关键代码，以表情为例： 12345678910111213//emojidocument.getElementById(&apos;emojiWrapper&apos;).addEventListener(&apos;click&apos;, function(e) &#123; //获取被点击的对象 var target = e.target; if (target.nodeName.toLowerCase() == &apos;img&apos;) &#123; //如果是表情图像则发送 var sendtxt = document.getElementById(&apos;sendtxt&apos;); sendtxt.focus(); sendtxt.value = sendtxt.value + &apos;[emoji:&apos; + target.num + &apos;]&apos;; &#125;;&#125;, false); 源码Gitbub地址：https://github.com/KMKNKK/Chatroom-WebSocket/tree/homework注意是homework的branch 重要文件结构： │ ├─index.html //客户端 │ ├─css │ bg.jpg //背景图 │ chat.css │ ├─images //图片资源 │ │ logo.png │ │ toNewMessage.png │ │ │ ├─emoji //表情 │ │ │ └─user //头像 │ │ ├─js │ │ app.js //服务端JS │ │ chat.js //客户端JS │ │ jquery.min.js //依赖 │ │ socket.io.js //依赖 │ │ │ └─.vscode │ settings.json │ ├─new //BootStrap和jQuery文件 │ │ jquery-3.2.1.min.js │ │ │ └─bootstrap-3.3.7-dist │ │ └─node_modules //依赖文件]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL四种匹配模式]]></title>
    <url>%2F2018%2F01%2F25%2FSQL%E5%9B%9B%E7%A7%8D%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[SQL提供了四种匹配模式：% _ [ ] [^ ] 1. %%表示模糊匹配0或多个字符，如以下查询语句：select * from user where name like &#39;%三%&#39;; 这个语句将会把name中带有“三”的信息全部查找出来select * from user where name like &#39;%三&#39; ; 这个语句将会把name中最右边带有“三”的信息全部查找出来select * from user where name like &#39;三%&#39; ; 这个语句将会把name中最左边带有“三”的信息全部查找出来 2. __表示任意单个字符，如以下语句: select * from user where name like &#39;_三_&#39;; 这个语句会匹配出“二三四” select * from user where name like &#39;__三&#39;; 这个语句会匹配出“一二三” 3. [ ][ ]表示括号内所列字符中的一个（类似于正则表达式），如以下语句：select * from user where name like &#39;老[大二三]&#39;; 如果都存在的话将找出“老大”、“老二”、“老三”同时支持缩写0-9、a-z等。 4.[^ ][^ ]类似于正则表达式，将括号内的元素排除，如以下语句：select * from user where name like &#39;[0-3]个&#39; 将会检索出除了“0个”，“1个”，“2个”，“3个”]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML常用头部标签]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%B8%B8%E7%94%A8%E5%A4%B4%E9%83%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[基本标签1&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt; 1&lt;meta charset='utf-8'&gt; &lt;!-- 声明文档使用的字符编码 --&gt; 1234&lt;html lang="zh-CN"&gt; &lt;!-- 页面采用中文（中国大陆范围，包括各种方言、繁体、简体等） --&gt;&lt;html lang="zh-cmn-Hans"&gt; &lt;!-- 简体中文（世界范围） --&gt;&lt;html lang="zh-cmn-Hant"&gt; &lt;!-- 繁体中文 --&gt;&lt;html lang="en-US"&gt; &lt;!-- 页面采用英文 --&gt; 1234&lt;title&gt;页面标题&lt;/title&gt;&lt;meta name="descirption" content="不超过150个字符"&gt; &lt;!-- 页面描述 --&gt;&lt;meta name="keywords" content="前端"&gt; &lt;!-- 页面关键词 --&gt;&lt;meta name="author" content="name,email@gmail.com"&gt; &lt;!-- 网页作者 --&gt; 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;!-- 使用IE最新版本渲染页面，若有chrome则优先使用chrome --&gt; 可选标签1&lt;base target="_blank"/&gt; &lt;!-- 设定页面中链接都在新窗口打开，默认为_self（在相同框架中打开） --&gt; 1&lt;meta http-equiv="Refresh" content="5;url=xxx"/&gt; &lt;!-- 在5秒后重新定向到指定链接 --&gt; 1&lt;meta name="renderer" content="webkit"&gt; &lt;!-- 当为双核浏览器时，优先使用webkit渲染 --&gt; 1&lt;link rel="dns-prefetch" herf="xxx"&gt; &lt;!-- dns预解析，提升图片加载速度，提升网站性能 --&gt; 1&lt;meta http-equiv="x-dns-prefetch-control" content="on"&gt; &lt;!-- 强制打开HTTPS的DNS预解析功能 --&gt; 移动设备12345678&lt;meta name="viewport" content="width=device-width,initial-scale=1,maximun-scale=1,userscalable=no"&gt;&lt;!--* width = device-width 自适应容器宽度* initial-scale 初始化缩放比例* minimum-scale 最小缩放比例* maximum-scale 最大缩放比例* user-scalable=no 禁止用户缩放,可以使得WebAPP更像原生应用--&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>前端-HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象创建的七种方式]]></title>
    <url>%2F2018%2F01%2F15%2F%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近在复习红宝书，里面介绍了对象创建的七种方式，分别是：1234567工厂模式构造函数模式原型模式构造函数和原型组合模式动态原型模式寄生构造模式稳妥构造模式 在这里总结一下，以便归纳学习。 工厂模式工厂模式通过函数接收参数来封装创建对象。包括以下步骤： (1)创建封装函数(2)显示地创建对象(3)将接收的参数和方法赋值给该对象(4)将创建的对象返回给实例 如下面例子：12345678910111213function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson("Sam", 20, "Software Engineer");var person2 = createPerson("Jack", 24, "Doctor"); 构造函数模式构造函数（constructor）方法与工厂模式有所不同，表现在： ☆ 没有在函数里显示地创建对象☆ 直接将属性和方法赋值给了this对象☆ 没有return语句☆ 构造函数名称首字母应大写 创建Person的新实例，必须使用new操作符。以这种方式调用构造函数会经历以下四个步骤：（1）创建一个新对象（2）将构造函数的作用域赋给新对象（于是this指向这个新对象）（3）执行构造函数中的代码（为该对象添加属性）（4）返回新对象给实例模拟new运算符过程：1234567891011121314var _new(func) &#123; var o = Object.create(func.prototype); /* * 第一步也可以写成： * var o = &#123;&#125;; * o.__proto__ === func.prototype */ var k = func.call(o); if(typeof k === Object)&#123; return k; &#125; else &#123; return o; &#125;&#125; 构造函数模式代码实现：1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person("Sam", 20, "Software Engineer");var person2 = new Person("Jack", 24, "Doctor"); 上面这种写法有一个缺点，就是由于作用域链的关系，每实例化一次Person构造函数都会创建一个新的sayName函数。两个实例中的同名实际上是两个独立开的函数，会造成不必要的开销。1alert(person1.sayName === person2.sayName); //false 因此我们可以像这样吧函数定义转移到构造函数之外：12345678910111213141516function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName() &#123; alert(this.name);&#125;var person1 = new Person("Sam", 20, "Software Engineer");var person2 = new Person("Jack", 24, "Doctor");//此时两个实例共享一个全局函数alert(person1.sayName === person2.sayName); //true 当然构造函数本质其实也是函数，你也可以把它当做普通函数来使用：12345678//作为普通函数调用Person("Greg", 27, "Doctor"); //添加到windowwindow.sayName(); //"Gray"//在另一个对象的作用域中调用var o = new Object();Person.call(o, "Kristen", 25, "Nurse");o.sayName(); //"Kristen" 原型模式&emsp;&emsp;我们创建的没一个函数都有一个原型（prototype）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。&emsp;&emsp;使用原型对象的好处是我们不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象当中。12345678910111213141516function Person() &#123;&#125;Person.prototype.name = "Sam";Person.prototype.age = 20;Person.prototype.job = "Software Engineer";Person.prototype.sayName = funtion() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // "Sam"var person2 = new Person();person2.sayName(); // "Sam"person1.sayName = person2.sayName // true 在创建实例时，我们仍然可以用new方法来实例对象，但是新的实例的属性和方法是共享的。 构造函数和原型函数结合这种方式集两种模式之长，每个实例都会有自己的一份构造函数中的实例属性副本，同时又共享着原型中的方法。12345678910111213function Person(name, age, job) &#123; //每个实例独有 this.name = name; this.age = age; this.job = job; this.friends = ["Shelby","Court"];&#125;Person.prototype = &#123; //共享的方法 constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125; 动态原型模式这个方法简单的来说就是先将所有信息封装在构造函数中，然后通过判断说需要的函数是否存在来动态地初始化原型。12345678910111213function Person(name, age, job) &#123; //属性 this.name = name； this.age = age; this.job = job; //方法 if(typeof this.sayName != "function") &#123; //不存在这个函数 Person.prototype.sayName = function() &#123; alert(this.name); &#125; &#125;&#125; 寄生构造函数模式简单的来说就是：构造模式的外表 + 工厂模式的内心这个方法用于在特殊情况下为对象创建构造函数。如：想创建一个具有自定方法的数组。由于无法直接更改数组的构造函数，可以用寄生构造方法来封装一个所需函数：12345678910111213141516function SpecialArray() &#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments)； //添加方法 values.toPipedString = function() &#123; return this.join("|"); &#125;; return values;&#125; var friend = new Person("Nicholas", 29, "Writer");friend.sayName(); //"Nicholas" 稳妥构造函数模式在安全环境下，不使用new和this12345678910111213function Person(name, age, job) &#123; var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); &#125;; return o;&#125;//在这个稳妥方法中，除了sayName()以外没有方法访问到name属性]]></content>
      <categories>
        <category>前端</category>
        <category>前端-JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[var & let & const]]></title>
    <url>%2F2018%2F01%2F10%2Fvar-let%2F</url>
    <content type="text"><![CDATA[本篇内容：梳理var、let、const的用法及注意事项，内容参考阮一峰《ES6标准入门》 var存在变量提升：只提升声明语句，不提升赋值语句我们来看下面这段代码12345678var foo = &#123;n:1&#125;;(function(foo)&#123; console.log(foo.n); foo.n = 3; var foo = &#123;n:2&#125;; console.log(foo.n);&#125;(foo);console.log(foo.n); 这段代码输出的结果是123123 这是因为函数内var声明变量提升造成的，我们将上面的代码改造一下，等效为下面的代码：123456789var foo = &#123;n:1&#125;;(function(foo)&#123; // 此时foo指向外部变量 var foo; // 变量提升,外部变量已声明，不做改变 console.log(foo.n); // 1 foo.n = 3; // 外部变量改变，n=3 foo = &#123;n:2&#125;; // foo指向改变为内部变量，并且n赋值为2 console.log(foo.n) // 函数内部变量，2&#125;)(foo);console.log(foo.n) // 3 let引入了块级作用域 let为JavaScript引入了类似于JAVA的块级作用域思想 只在let声明时的作用域里有效ES6新增了let命令，用来声明变量，用法类似于var,不同之处在于let声明的变量只在其命令所在的代码块内有效，而var在全局范围内有效。类似于C++和JAVA中的声明语句。 1234567&#123; let a = 10; var b = 1;&#125;a; // ReferenceError: a is not defined.b; // 1 这样可以大大改善代码中由于全局变量而引发的错误，比如以下代码：12345678var a = [];for(var i = 0; i &lt; 10; i++)&#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[6](); // 10 上述代码由于变量i是用var声明的，所以在全局范围有效，当循环体执行完时，i = 10，当我们在外部调用时，console.log(i)中的i实际上是指向全局变量i的，于是输出为10。 让我们来看看使用let的情况：12345678var a = [];for(let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[6](); // 6 上述代码中，由于i是由let定义的，所以只在本轮for循环中有效，所以console.log(i)中的i指向的其实是10个不同的i，所以在外部调用的时候，其结果就为该轮赋值给i的结果。 不存在变量提升let命令所声明的变量一定要在声明语句之后使用，类似于C++和JAVA。12345console.log(foo); // undefinedvar foo = 2;console.log(bar); // ReferenceErrorlet bar = 2; 暂时性死区只要块级作用域中存在let命令，它说声明的变量就绑定在了这个区域，不受外部影响。12345678910var tmp = 123;if(true) &#123; tmp = 'abc'; // ReferenceError let tmp; tmp = 10; console.log(tmp); // 10&#125;console.log(tmp); // 123 上述代码中，虽然存在全局变量tmp，但是在块级作用域内let又生声明了一个同名的局部变量，此时在这个块级作用域内形成了封闭作用域，变量tmp受let管理，与全局变量独立开。 不允许重复声明let在相同作用域内不允许重复声明，而var允许这么做。 const 类似于C++，JS的const变量不得改变值const变量声明时必须赋值与let相同，const变量只在说声明的块级作用域内有效]]></content>
      <categories>
        <category>前端</category>
        <category>前端-JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS3：transform]]></title>
    <url>%2F2018%2F01%2F07%2Ftransform%2F</url>
    <content type="text"><![CDATA[CSS transform 属性只对block级属性有效 旋转1transform: rotate(angle); /* an &lt;angle&gt;, e.g. rotate(30deg) */ 从原点(由transform-origin属性指定)开始按照顺时针方向旋转元素一个特定的角度。12345678910// 一个值：&lt;length&gt;，&lt;percentage&gt;，或 left, center, right, top, bottom关键字中的一个。// 两个值：其中一必须是&lt;length&gt;，&lt;percentage&gt;，或left, center, right关键字中的一个。另一个必须是&lt;length&gt;，&lt;percentage&gt;，或top, center, bottom关键字中的一个。// 三个值：前两个值和只有两个值时的用法相同。第三个值必须是&lt;length&gt;。它始终代表Z轴偏移量。 缩放1transform: scale(sx[,sy]); /* one or two unitless &lt;number&gt;s, e.g. scale(2,4) */ X方向缩放1transform: scaleX(sx); /* a unitless &lt;number&gt;, e.g. scaleX(2.7) */ Y方向缩放1transform: scaleY(sy); /* a unitless &lt;number&gt;, e.g. scaleY(0.3) */ 倾斜1transform: skew(ax[,ay]); /* one or two &lt;angle&gt;s, e.g. skew(30deg,-10deg) */ X方向倾斜1transform: skewX(angle); /* an &lt;angle&gt;, e.g. skewX(-30deg) */ Y方向倾斜1transform: skewY(angle); /* an &lt;angle&gt;, e.g. skewY(4deg) */ 平移1transform: translate(tx[,ty]); /* one or two &lt;length&gt; values */ X方向平移1transform: translateX(tx); Y方向平移1transform: translateY(ty);]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS:元素和基本定位]]></title>
    <url>%2F2018%2F01%2F05%2FCSS-%E5%85%83%E7%B4%A0%E5%92%8C%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[元素块级元素(disply：block)这类元素显示为一块内容，即”块框”,常见的块级元素有：123456menup,preh1~h6,hrdiv,dir,dltable,ul,ol,li,formaddress,blockquote,center 行内元素(display：inline)strong、span等元素，这些内容显示在行中，即”行内框”。 行内盒元素（display：inline-block）顾名思义，这个定义使得元素像行内元素一样水平依次排列，但是框的内容仍然符合块级框的行为。例如可以显示地设置宽度、高度、垂直外边距和内边距。 我们可以使用dispaly来更改元素的类型：12345display: block //使行内元素表现的像块级元素一样display: inline //默认值，像行内元素一样显示display: inline-block //行内盒元素display: list-item //像列表项一样显示display: none //使这个框的内容不显示，不占用文档空间 CSS中的基本定位方式☆ 普通流☆ 浮动☆ 绝对定位（position：absolute）☆ 相对定位（position：relative）☆ 固定定位（position：fixed）☆ 继承定位（position：inherit）☆ 默认定位/无定位（position：static） 1、普通流除非专门指定，否则所有框均在普通流中定位普通流中元素框的的位置由元素在HTML中的位置决定 块级框从上到下一个接一个垂直排列，垂直距离由垂直外边距决定，可能会发生margin合并现象。 行内框在一行中水平排列，可以使用水平内边距、边框、外边距来调整它们的水平间距。但是垂直外边距、边框、外边框并不会影响行内框的高度。在行内框上设置显式地高度和宽度也没有影响。 由一行形成的水平框成为行框，行框的高度总是足以容纳其包含的所有行内框。即：行框高 = Max(所含行内框的高)可以通过设置行高进而间接(在视觉上)增加行内框的高度。 2、浮动 浮动不占据文档流的空间，但是文本会会环绕在浮动元素周围，可能会覆盖掉文档流元素。 框1脱离文档流向右浮动直到碰到边界：浮动元素之间会相互影响：文本环绕在浮动元素周围：可以通过给文本元素增加clear属性（left、right、both、none）来表示哪边不应该挨着浮动框以达到上图左边的效果。 清除浮动：(1)overflow:hidden 这个方法可以清除浮动，但会产生BFC，强制包裹住元素，导致内容被截断或产生滚动条。(2)clear类方法(推荐)1234567.clear:after &#123; content: &quot;.&quot;; height: 0; visibility: hidden; display: block; clear: both;&#125; 3、绝对定位12345#myBox &#123; position: absolute; left: 20px; top: 20px;&#125; 绝对定位使元素位置与文档流无关，因此不占据文档空间。普通文档流元素就当绝对定位元素不存在一样。 4、相对定位12345#myBox &#123; position: relative; left: 20px; top: 20px;&#125; 在使用相对定位时，无论是否移动，元素仍然占据原来的空间（占据文档空间）。因此，移动元素会导致覆盖其他框。 5、固定定位1position: fixed; 将元素从文档流中移除，使元素固定在窗口某一位置不动，并且跟随页面滚动始终处于页面固定的位置。 6、继承定位1position: inherit; 顾名思义，从父类元素继承定位属性。 7、默认值1position: static; 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js 读写文件]]></title>
    <url>%2F2017%2F12%2F27%2FNode-js-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在看这篇文章之前，我觉得你需要对JavaScript中的Buffer对象和同步异步有所了解。 关于Buffer对象，我推荐阮一峰老师的这一篇：Buffer对象 而同步异步我推荐你去看看掘金上的一篇文章：这一次，彻底弄懂JavaScript执行机制，不局限与同步异步，非常值得一看。 模块导入我们要读写文件，首先要导入Node.js内置的fs模块即文件系统模块(类似于JAVA里面的包或者类，里面封装了方法) 123'use strict'var fs = require('fs'); 读文件(1)异步方法:1234567891011'use strict'var fs = require('fs');fs.readFile('test.txt','utf-8',function(err,data) &#123; //读取文本文件 if(err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 这个方法包含三个参数：文件索引地址、编码格式、回调函数。其中回调函数接收两个参数，错误对象err和读取的数据data。 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）：12345678fs.readFile('sample.png', function (err, data) &#123; //读取二进制文件 if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + ' bytes'); &#125;&#125;); Buffer对象和String之间可以相互转化：12345//Buffer -&gt; Stringvar text = data.toString('utf-8');//String -&gt; Buffervar buf = Buffer.from(text,'utf-8'); (2)同步方法： 12345'use strict';var fs = require('fs');var data = fs.readFileSync('sample.txt', 'utf-8');console.log(data); 相比于异步函数，多了Sync(同时、同步)后缀，不接受回调函数。函数直接返回结果，需要用try...catch来捕获错误：123456try&#123; var data = fs.readFileSync('test.txt','utf-8'); console.log(data);&#125; catch(err) &#123; console.log(err);&#125; 写文件大体原理与读文件类似，这里就不赘述了,需要注意的是跟python一样，JS的写入会覆盖掉先前存在的文本。贴一下大体代码：12345678910111213141516'use strict';var fs = require('fs');var data = 'Hello';//异步方法，接受参数：文件索引地址、数据、回调函数。传入String则默认按UTF-8编码。fs.writeFile('test.txt',data,function(err)&#123; if(err) &#123; console.log(err); &#125; else&#123; console.log('ok.'); &#125;&#125;);//同步方法fs.writeFileSync('test.txt',data); 博主在测试中发现，当同时进行异步读写时，无论两者的函数谁在前，都会先执行写的操作。 文件状态如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：1234567891011121314151617181920212223242526'use strict';var fs = require('fs');//异步实现fs.stat('sample.txt', function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); &#125; &#125;&#125;);//同步实现var stat = fs.statSync('test.txt'); Stream流方式123456789101112131415161718192021222324252627282930313233343536373839404142434445'use strict';var fs = require('fs');// 打开一个读取流:var rs = fs.createReadStream('sample.txt', 'utf-8');rs.on('data', function (chunk) &#123; console.log('DATA:') console.log(chunk);&#125;);rs.on('end', function () &#123; console.log('END');&#125;);rs.on('error', function (err) &#123; console.log('ERROR: ' + err);&#125;);//打开一个写入流：var ws1 = fs.createWriteStream('output1.txt', 'utf-8');ws1.write('使用Stream写入文本数据...\n');ws1.write('END.');ws1.end();var ws2 = fs.createWriteStream('output2.txt');ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));ws2.write(new Buffer('END.', 'utf-8'));ws2.end();//pipe//在Node.js中，Readable流有一个pipe()方法，可以把一个文件流和另一个文件流串起来//这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：'use strict';var fs = require('fs');var rs = fs.createReadStream('sample.txt');var ws = fs.createWriteStream('copied.txt');rs.pipe(ws);//默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数：readable.pipe(writable, &#123; end: false &#125;);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git fetch & pull 详解]]></title>
    <url>%2F2017%2F12%2F26%2Fgit-fetch%E5%92%8Cpull%2F</url>
    <content type="text"><![CDATA[1.简单概括先用一张图来理一下git fetch和git pull的概念： 可以简单的概括为： git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。 下面我们来详细了解一下git fetch 和git pull 的用法。 2.分支的概念在介绍两种方法之前，我们需要先了解一下分支的概念：分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。 如下图所示，当前有2个分支，A,C,E属于master分支，而A,B,D,F属于dev分支。 123A----C----E（master） \ B---D---F(dev) 它们的head指针分别指向E和F，对上述做如下操作： 12git checkout master // 选择 or 切换到master分支git merge dev // 将dev分支合并到当前分支(master)中 合并完成后： 123A---C---E---G(master) \ / B---D---F（dev） 现在A,B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而ABDF依然属于dev分支。可以继续在dev的分支上进行开发: 123A---C---E---G---H(master) \ / B---D---F---I（dev） 分支（branch）的基本操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546git branch //查看本地所有分支 git branch -r //查看远程所有分支git branch -a //查看本地和远程的所有分支git branch &lt;branchname&gt; //新建分支git branch -d &lt;branchname&gt; //删除本地分支git branch -D &lt;branchname&gt; //删除远程分支，删除后还需推送到服务器git push origin : &lt;branchname&gt; //删除后推送至服务器或者：git push origin --delete &lt;branchName&gt;git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; //重命名本地分支/***重命名远程分支：*1、删除远程待修改分支*2、push本地新分支到远程服务器*///git中一些选项解释:-d--delete：删除-D--delete --force的快捷键-f--force：强制-m--move：移动或重命名-M--move --force的快捷键-r--remote：远程-a--all：所有 3.git fetch 用法git fetch 命令：1$ git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地 如果只想取回特定分支的更新，可以指定分支名： 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格 最常见的命令如取回origin 主机的master 分支： 1$ git fetch origin master 取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1$ git log -p FETCH_HEAD 如图： 可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。 我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 4.git pull 用法前面提到，git pull 的过程可以理解为：12git fetch origin master //从远程主机的master分支拉取最新内容 git merge FETCH_HEAD //将拉取下来的最新内容合并到当前所在的分支中 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为： 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略： 1$ git pull origin next 5.参考文章阮一峰老师博客: Git远程操作详解简书: git中fetch和pull的区别CSDN: git branch用法总结，查看、新建、删除、重命名博客园: Git中pull对比fetch和merge]]></content>
      <categories>
        <category>Git/Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DigitalOcean学生优惠]]></title>
    <url>%2F2017%2F12%2F25%2FDigitalOcean%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0%2F</url>
    <content type="text"><![CDATA[前言:之前在教你用shadowsocks和vps科学上网中使用的VPS到期并且续费比较贵所以最近转用了DigitalOcean，由于Github提供50刀的学生优惠，所以基本上可以免费使用一年低配VPS，虽然比之前的稍微慢一点，但是是免费的呀！ 具体操作步骤如下： (1)在Github上申请成为学生账号（只需要有学生邮箱即可，一般大学都提供学生邮箱，例如博主就是在教务处申请的以edu.cn结尾的教育邮箱）(2)成为学生账号后，Github会给你一个education package，里面有一大堆优惠，其中就包括DigitalOcean的$50兑换码(以前是$100),复制这个兑换码 (3)在DigitalOcean上创建一个账号 (4)用Paypal支付$5以激活账号 (5)在Billing中输入兑换码，这样你账户中就有$55了 (6)接下来就是 开通VPS - 第一次登陆修改密码 - 配置shadowsocks 了，流程跟教你用shadowsocks和vps科学上网中一致，不过不需要升级Ubuntu，省去了麻烦的一步 (7)开始科学上网吧！]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IM即时聊天室（二）: Socket.io + Node.js]]></title>
    <url>%2F2017%2F12%2F21%2FIM%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E4%BA%8C%EF%BC%89-Socket-io%2F</url>
    <content type="text"><![CDATA[前言在IM即时聊天室（一）中,我们了解了WebSocket的相关知识和基础API作为编写聊天室的基础。那么作为进阶篇，今天我们就来讲一讲Socket.io 1、什么是Socket.io？简单来说，Socket.io封装了WebSocket以及其他的一些协议，是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。 它包括了客户端的JavaScript和服务器端的Node.js并且实现了WebSocket的服务端代码。同时还有很强的兼容性，兼容各种浏览器以及移动设备。有了它，我们能更方便快捷地实现服务器端与客户端之间的实时通讯。 2、使用Socket.io（初始化）服务端搭建： 服务端我使用的是Node.js，安装的话就直接点左边的链接下载对应的安装包就好啦，Linux稍麻烦一点需要配置一下node和npm的全局执行环境，网上有很多的教程，在这里就不赘述了。 安装好Node.js后，创建一个文件夹作为项目文件夹，定位到刚建的文件夹下，输入npm install socket.io安装Socket.io 安装完成之后，可以看到文件夹下多了node_modules文件，里面全是刚下载的socket.io依赖包。 初始化服务端： 创建一个app.js文件作为服务端代码 1234567891011121314151617181920212223/*app.js*//*构建http服务*/var app = require(&apos;http&apos;).createServer()/*引入socket.io*/var io = require(&apos;socket.io&apos;)(app);/*定义监听端口，可以自定义，端口不要被占用*/var PORT = 8081;/*监听端口*/app.listen(PORT);/***监听客户端连接*io是我们定义的服务端的socket*回调函数里面的socket是本次连接的客户端socket*io与socket是一对多的关系*/io.on(&apos;connection&apos;, function (socket) &#123; /*所有的监听on，与发送emit都得写在连接里面，包括断开连接*/&#125;) 对比WebSocket服务端初始化代码： 12345678910111213141516171819// 导入WebSocket模块:const WebSocket = require(&apos;ws&apos;);// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化: 在3000端口上打开一个WebSocket Serverconst wss = new WebSocketServer(&#123; port: 3000&#125;);//监听connection事件wss.on(&apos;connection&apos;, function (ws)&#123; /** *监听客户端事件 *回调函数里面的socket是本次连接的客户端socket *io与socket是一对多的关系 */&#125;); WebSocket流程：导入Websocket模块 - 创建server - 在自定义端口创建实例 - 在该端口监听事件Socket.io流程： 导入http模块 - 创建HttpServer - 基于HttpServer创建Socket.io实例 - 在自定义端口监听事件 可以看到，Socket.io的服务端初始化代码和WebSocket相比，流程相近。那么Socket.io的优势在哪呢？ 1.Socket.IO已经具有众多强大功能的模块和扩展API 2.Socket.IO实现了实时、双向、基于事件的通讯机制,它解决了实时的通信问题，并统一了服务端与客户端的编程方式。启动了Socket以后，就像建立了一条客户端与服务端的管道，两边可以互通有无。 接下来是初始化客户端： 12345678/***客户端初始化非常简单*只需要创建一个实例并指向目标服务器，注意端口要与服务器端保持一致*/var socket = io(&apos;ws://localhost:8081&apos;);//WebSocket客户端初始化代码:var ws = new WebSocket(&quot;ws://localhost:3000&quot;); 3、使用Scoket.io（API函数介绍）1、客户端部分： 客户端向服务器端发送消息例如客户端向服务端发送登录请求12//login是自定义的事件，后面是带的信息socket.emit(&apos;login&apos;,&#123;username:uname&#125;) 监听服务端发来的信息123socket.on(&apos;String&apos;,function(data)&#123; //...) 给除了自己以外的客户端广播消息1socket.broadcast.emit 2、服务端部分： 监听客户端连接,回调函数会传递本次连接的socket，下面列出的函数都要写在这个函数里123io.on(&apos;connection&apos;,function(socket)&#123; //...)); 给指定的客户端发送消息1io.sockets.socket(socketid).emit(&apos;String&apos;, data); 给所有客户端广播消息1io.sockets.emit(&apos;String&apos;,data); 给当前正在处理的socket的客户端发送消息1socket.emit(&apos;String&apos;, data); 监听客户端发送的信息123socket.on(&apos;String&apos;,function(data)&#123; //...));]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IM即时聊天室（一）：WebSocket]]></title>
    <url>%2F2017%2F12%2F18%2FIM%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AWebSocket%2F</url>
    <content type="text"><![CDATA[1、什么是WebSocket?它和Socket有什么关系？在网络中，两个程序（进程）需要全双工通信，即双方可以同时向对方发送消息，需要用到的就是Socket，它能够提供端对端通信。 具体的实现过程如下： (1)客户端：创建一个Socket实例，并且提供服务端的IP和端口，如：192.168.1.1:8081 (2)服务端：创建另一个Socket并绑定本地端口进行监听，如：localhost:8081 (3)两者约定的端口要相同 (4)客户端对服务端进行请求连接，服务端接受后通知客户端，双方就建立了一个TCP连接 (5)至此，客户端和服务端之间可以进行双向通信，并且无客户端和服务端之分，均为端对端通信，但是主流的IM还是采用服务端转发的方式进行消息传送。 WebSocket借鉴了socket的思想，为web应用程序的客户端和服务端之间提供了一种全双工通信机制（注意：在WebSocket中是有客户端和服务端之分的）。 不同于原生Socket的端到端直接通信，WebSocke采取的方式是让所有客户端连接服务端，服务器再将不同客户端发送给自己的消息进行转发或者广播。 2、Websocket的通信原理虽然WebSocket是一种新应用层协议，但既然是基于Web端的技术，就无法脱离HTTP而单独存在。但是它和HTTP最大的不同是: 1、WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样 2、WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信 所以当我们构建一个WebSocket实例的时候，实际上过程是这样的： (1)客户端发送一个 http Get 请求报文，告诉服务端：我要将通信协议切换到WebSocket啦！发送的数据格式类似下面的内容： 12345678910111213GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13//该请求和普通的HTTP请求有几点不同：//GET请求的地址不是类似/path/，而是以ws://开头的地址；//请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；//Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；//Sec-WebSocket-Version指定了WebSocket的协议版本。 (2)如果服务端支持WebSocket协议，那么服务端就会将自己的通信协议切换为WebSocket，同时回传给客户端一个状态码为101的响应报头，该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= (3)以上过程称之为WebSocket协议握手（WebSocket Protocol handshake），有点类似于TCP三次握手，实际上这个WebSocket也确实是基于我们刚才发起的http的TCP连接。 (4)然后就可以通过WebSocket进行服务端和客户端之间的连接啦，其提供两种数据传输方式：文本数据和二进制数据。 WebSocket出现前，Web端的即时通讯方法(Comet)： 长轮询客户端首先给服务端发送一个请求，服务端收到该请求之后如果数据没有更新则并不立即返回，服务端阻塞请求的返回，直到数据发生了更新或者发生了连接超时，服务端返回数据之后客户端再次发送同样的请求。 基于流式数据传输的长连接通常的做法是在页面中嵌入一个隐藏的iframe,然后让这个iframe的src属性指向我们请求的一个服务端地址。并且为了数据更新，我们将页面上数据更新操作封装为一个js函数，将函数名当做参数传递到这个地址当中。 服务端收到请求后解析地址取出参数（客户端js函数调用名）每当有数据更新的时候，返回对客户端函数的调用，并且将要跟新的数据以js函数的参数填入到返回内容当中。 4、WebScoket基本API服务端： 123456789101112131415161718192021222324252627// 导入WebSocket模块:const WebSocket = require(&apos;ws&apos;);// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化: 在3000端口上打开一个WebSocket Serverconst wss = new WebSocketServer(&#123; port: 3000&#125;);/***监听connection事件*回调函数里面的ws是本次连接的客户端socket*io与ws是一对多的关系*/wss.on(&apos;connection&apos;, function (ws) &#123; console.log(`[SERVER] connection()`); ws.on(&apos;message&apos;, function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); ws.send(`ECHO: $&#123;message&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;)&#125;); 客户端： 1234567891011var ws = new WebSocket(&quot;ws://localhost:3000&quot;);//建立连接 ws.onopen = function()&#123;ws.send(“Test!”); &#125;;//响应收到的信息 ws.onmessage = function(evt)&#123;console.log(evt.data);&#125;; //关闭连接ws.onclose = function(evt)&#123;console.log(“WebSocketClosed!”);&#125;;//出错 ws.onerror = function(evt)&#123;console.log(“WebSocketError!”);&#125;;//向服务端发送信息ws.send(&apos;xxx&apos;);]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈BFC和margin重叠]]></title>
    <url>%2F2017%2F12%2F12%2F%E6%B5%85%E8%B0%88BFC%2F</url>
    <content type="text"><![CDATA[写在前面：本文是我在看了CSS：潜藏着的BFC、为什么这么多人讲不清楚 BFC两篇文章后做做出的关于CSS的总结，如有错误与不足，欢迎指正，不胜感激！ 什么是BFC（Block Formatting Context）我们先来看BFC的定义：块级格式化上下文，指一个独立的块级渲染区域，该区域有一套渲染规则来约束块级盒子布局,浮动层元素可再次进行交互,且与区域外部无关。 那么BFC是如何产生的呢？查阅MDN可以看到，满足下列条件之一便会生成BFC: 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素的 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素，一般默认为visible display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 最好的方法应该是使用display：flow-root ，不过部分浏览器不支持。 BFC内部的渲染布局规则及功能简单归纳如下： 1.内部元素会在垂直方向一个接一个地排列 2.垂直方向上，两相邻盒子的margin会发生合并 举一个简单的例子：1234567891011.father&#123; border: 1px solid; min-height: 100px; display: flow-root;&#125;.son&#123; border: 1px solid red; background-color: red; height: 10px; margin: 10px 0px;&#125; 首先创建一个父块，里面包含两个相同的子块，子块的margin设置为 10px 0px；那么理论上这两个子块中间的margin应该为10+10=20px，结果却只有10px； 当我们把下方的子块margin变为20px 0px时，理论上中的margin应该为10+20=30px；结果却只有20px； 1234567891011121314151617.father&#123; border: 1px solid; min-height: 100px; display: flow-root;&#125;.son&#123; border: 1px solid red; background-color: red; height: 10px; margin: 10px 0px;&#125;.son1&#123; border: 1px solid red; background-color: red; height: 10px; margin: 20px 0px;&#125; 造成这种现象的原因就是margin合并： 块的顶部外边距和底部外边距有时被组合(折叠)为单个外边距，其大小是组合到其中的最大外边距，这种行为称为外边距塌陷(margin collapsing)，有的地方翻译为外边距合并。只有普通文档流块框的垂直外边距会叠加。行内框、浮动框、绝对定位框之间的外边距不会叠加。空元素的上下margin也会叠加常见的有父子margin重叠，兄弟margin重叠 通俗地来说，BFC内相邻两元素的margin会发生合并，并且合并为两者中较大的那一个。 但是在不同的BFC中的两个元素不会发生重叠，我们可以用这一特性在日常页面中防止margin合并，如： 12345678910111213&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;div style="overflow:hidden;"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;.son&#123; border:1px solid red; margin : 10px 0px; min-height:10px; background-color: red;&#125; 此时这两个son块不会发生margin重叠： 3.BFC中的子元素(包括浮动元素)不会超出BFC的范围 BFC里的子元素即使是float也会参与BFC的高度计算，而不像脱离文档流那样脱离BFC 使用场景：用BFC包住浮动元素(清除浮动)点此查看参考代码 BFC可以用于清除浮动的效果，但是会带来内部元素无法出父元素的副作用。清除浮动还是用.clearfix比较好。 4.BFC内部东西与外部不重合，可以用于不同组件间划清界限 使用场景：用 float + div 做左右自适应布局，避免了侵占浮动元素点此查看参考代码]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈一谈对象]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[别想太多，是JavaScript对象 = v = 不同于JAVA这类面向对象（Object-Oriented，OO）的语言，JavaScript没有类的概念。因此它的对象也与基于类的语言中的对象有所不同。 ECMA-262中把对象定义为：无序属性的集合，属性可以包含基本值、对象或者函数 简单点来说，JS中的对象就是指由若干键值对组成的无序数据类型的集合。一般用{...}来表示一个对象，用xxx : xxx的格式来申明变量以及赋值，并以,分隔开，最后一个键值对末尾不加,如下面的例子: 123456789101112131415var animal = &#123; type: &quot;animal&quot;, age: null, roar_sound: null, roar: function()&#123; console.log(this.roar_sound); &#125;&#125;;animal.type; //&quot;animal&quot;animal[&apos;type&apos;];//&quot;animal&quot;animal.age; //nullanimal[&apos;age&apos;]; //nullanimal.roar(); //null 这个例子创建了一个animal对象，我们可以用 animal.xxx 或者 animal[&#39;xxx&#39;]/animal[&quot;xxx&quot;] 的方式来访问该对象的某一值。 PS：若属性名需要包含特殊字符串时，则需要用&quot; &quot;/&#39; &#39;括起来，并且只能通过xxx[‘xxx’]的方式来访问该对象,如： 1234567var person = &#123;&apos;first-name&apos; : &apos;Tom&apos;,&apos;second-name&apos; : &apos;Riddle&apos;&#125;//仅能用以下方式访问对象person[&apos;first-name&apos;]; //&quot;Tom&quot;person[&apos;second-name&apos;];//&quot;Riddle&quot; 给JS对象增加或删除属性：由于JS的对象是动态类型，所以我们可以自由的给对象增加或删除属性。 12345678var person = &#123;&#125;;person.name; //不存在,undefinedperson.name = &quot;Tony&quot;;person.name; //&quot;Tony&quot;delete person.name; //不存在,undefined 判断一个属性是否存在于对象中：我们可以使用in来判断一个属性是否存在于对象中，例如： 1234567var person = &#123;name : &apos;Tom Riddle&apos;age : &apos;infinity&apos;&#125;&apos;name&apos; in person; //true&apos;type&apos; in person; //false 但是，通过这个方法来判别有个缺点，就是你无法知道这个属性是对象本身有的还是通过继承得到的。比如Person中有name属性，tony继承于person，于是tony也有了name属性，但这并不是他本身所自有的。 为了判断属性是否为对象所自有的，我们可以使用对象名.hasOwnProperty(&#39;属性名&#39;)的方法来判断： 12345var xiaoming = &#123; name: &apos;小明&apos;&#125;;xiaoming.hasOwnProperty(&apos;name&apos;); // truexiaoming.hasOwnProperty(&apos;toString&apos;); // false 注：总结于廖雪峰老师的教程，高程上的Object.defineProperty( ); 暂时没看出用途，等写到了再回来填坑。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型]]></title>
    <url>%2F2017%2F12%2F04%2FCSS%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[盒模型包括四部分内容：内容(content),填充(padding),边界(margin),边框(border) 盒模型有两种：IE盒模型 和 W3C盒模型(标准盒模型) 如下图所示，两种盒模型最大的区别在于: W3C盒模型:&nbsp;width/height = content; IE盒模型:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width/height = content + padding + border 浏览器默认使用content-box(W3C盒模型)，如果DOCTYPE缺失，在IE6，IE7，IE8下会触发IE盒模型(怪异模式)当然我们也可以使用CSS人为的切换成自己想要的盒模型： 1234567/* W3C盒模型 *//* width/height = content */`box-sizing:content-box;/* IE盒模型 *//* width/height = border + padding + content */`box-sizing:border-box; 那么在开发过程中我们如何使用JS设置/获取盒模型对应的宽高呢？主要有以下方式： 12345678910111213141516171819(1)dom.style.width/height 获得内联样式(2)dom.currentStyle.width/height 获得渲染以后即实时的宽高，但只有IE支持(3)window.getComputedStyle(dom).width/height 同上，兼容Chrome等(4)dom.getBoundingClientRect().width/height dom.getBoundingClientRect() 的返回值情况： left: 包围盒左边 border 以外的边缘距页面左边的距离 right: 包围盒右边 border 以外的边缘距页面左边的距离 top: 包围盒上边 border 以外的边缘距页面顶部的距离 bottom: 包围盒下边 border 以外的便于距页面顶部的距离 width: content + padding + border height: content + padding + border(5)dom.clientWidth = content + padding dom.clientHeight = content + padding]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[教你用shadowsocks和vps科学上网]]></title>
    <url>%2F2017%2F11%2F30%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;写在前面：作为一个程序员，用正确的姿势科学上网是必备技能，以前需求量不大的时候都是用各种免费的VPN看看外网，但是最近各种软件陆续倒下，加上自己看外网教程、技术文档，上Flickr的需求越来越多，决定还是用shadowsocks+VPS自己搭一个梯子比较舒服。 话不多说，先上图： HD画质连接速度近4Mbps，阿爸很满意并且嫌弃的看了一眼校园网。 接下来给大家介绍一下整个搭建过程 VPS给大家推荐一款vps:openvzvps，国人弄的VPS网站：https://www.50vz.net/aff.php?aff=886上面有各种规格的VPS，最便宜的年付￥70，每月500G流量，看剧什么的应该够了。 付款成功后，你就拥有自己的vps啦，官网会发一封邮件给你，里面包含了VPS的IP和初始密码。 你也可以在 客户中心-虚拟服务器管理-我的虚拟服务器 里面你可以看到刚才购买的vps，默认装的是cent os ,不过我换了ubuntu，本教程也基于ubuntu。 所以推荐你点击重装系统，然后选择ubuntu，设置新密码，一定要记得这个密码，登陆服务器的时候会用到。大约1-3分钟，系统很快就会安装好。 SSH连接VPS您可以用以下工具来登陆您的VPS: Putty: http://api.ifdream.net/soft/putty.zip Xshell:http://api.ifdream.net/soft/Xshell.zip 随便用一种工具，输入你的VPS的IP地址，端口为默认端口，然后连接。接着以root的身份登录，并输入你的VPS密码，若没设置新密码则输入邮件里的初始密码。 第一次登录时，OpenVZVPS会让你设置一下你的私人端口，以提高安全性，以后登录的时候就用这个端口登录。 接下来OpenVZVPS会更新Ubuntu相关文件，在这里博主出现了卡顿现象，上网查解决方案发现是因为系统默认使用IPV6来连接网络，但是博主校园网并不支持IPV6… 解决方案是使用WinSCP登录服务器，找到gai.config这个文件地址为/etc/gai.conf，并且将第54行前面的#去掉，也就是取消注释，这样就是允许使用IPV4连接。 123将这一行: #precedence ::ffff:0:0/96 100变为: precedence ::ffff:0:0/96 100 等待ubuntu安装好后退出，用putty或Xshell再次登录VPS就好啦。 安装shadowsockes使用命令一条一条的输入，$ sudo可以不用输入，安装shadowsocks 1234$ sudo apt-get update$ sudo apt-get install python-gevent python-pip$ sudo pip install shadowsocks$ apt-get install python-m2crypto 配置Shadowsocks全部安装好后，就可以开始配置config了 创建shadowsocks.json文件 vi /etc/shadowsocks.json 使用vim语句创建并编辑shadowsocks.json ，对vim不熟的同学也可以使用WinSCP来手动创建一个并编辑。 修改shadowsocks.json 将password改为你的VPS密码，localport改为你之前设置的的私人端口，接着保存就好啦 12345678&#123; "server":"0.0.0.0", "server_port":8388, "local_port":1080, "password":"password", "timeout":600, "method":"aes-256-cfb"&#125; 运行Shadowsocks123$ su -ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 上面两行代码分别是开启和关闭shadowsocks服务，这里我们打开就好啦。至此服务端建设完毕。 接下来下载shadowsocks客户端： Windows：https://github.com/shadowsocks/shadowsocks-windowsAndroid：https://github.com/shadowsocks/shadowsocks-androidIOS：https://github.com/shadowsocks/ShadowsocksX-NG 安装好后，配置端口，IP地址，密码，选择加密方式（都跟shadowsocks.json一致即可） 然后就可以开心的科学上网啦~]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不定期更新的图文]]></title>
    <url>%2F2017%2F11%2F28%2F%E6%AF%8F%E6%97%A5%E5%9B%BE%E6%96%87%2F</url>
    <content type="text"><![CDATA[Photo by Lance Asper on Unsplash2018 / 03 / 10&nbsp;南京&nbsp;晴&nbsp;二月最后一天2018 / 02 / 28&nbsp;南京&nbsp;雾&nbsp;这几天把之前积累的零碎知识点好好归类总结一下2018 / 02 / 21&nbsp;永新&nbsp;阴&nbsp;学Webpack有种在Window配环境变量的既视感= =2018 / 02 / 18&nbsp;永新&nbsp;晴&nbsp;昨天拍的初雪，和小五一样好看。2018 / 01 / 05&nbsp;南京&nbsp;晴&nbsp;甜甜甜甜甜 2018 / 01 / 01&nbsp;南京&nbsp;多云&nbsp;&nbsp;今天没啥特别的话，&nbsp;就是想发一下这张好看的图:)2017 / 12 / 29&nbsp;南京&nbsp;小雨&nbsp;怀念躺在沙漠里，&nbsp;看流星的那一夜。2017 / 12 / 28&nbsp;南京&nbsp;小雨&nbsp;不管你愿不愿意，&nbsp;时间它就这么滴答滴答地流逝了。&nbsp;所以少年啊，快点去创造奇迹吧！2017 / 12 / 26&nbsp;南京&nbsp;晴念念不忘，必有回响。&nbsp;考研的师兄师姐们加油！2017 / 12 / 22&nbsp;南京&nbsp;晴&nbsp;Stay foolish,stay hungryand&nbsp;Keep going…2017 / 12 / 18&nbsp;南京&nbsp;晴&nbsp;你没病，也很棒，别妄自菲薄2017 / 12 / 12&nbsp;南京&nbsp;又一个很棒的晴天&nbsp;怎样都好，只是别停下前进的步伐。2017 / 12 / 07&nbsp;南京&nbsp;多云&nbsp;考完编译原理，又可以开心地造轮子了。2017 / 12 / 06&nbsp;南京&nbsp;晴&nbsp;希望每一个孩子都能被善待。2017 / 11 / 30&nbsp;南京&nbsp;小雨]]></content>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法的JavaScript实现]]></title>
    <url>%2F2017%2F11%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序什么时候最快当输入的数据已经是正序时: O(n)什么时候最慢当输入的数据是反序时: O(n²)冒泡排序动图演示JavaScript代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;———-快速排序 快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(n log n) ，且O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 快速排序动图演示JavaScript代码实现1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != &apos;number&apos; ? 0 : left, right = typeof right != &apos;number&apos; ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; //分区操作 var pivot = left, //设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 先写这两种吧。。算法好多都忘了要慢慢补了QAQ]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端安全：XSS和CSRF]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[CSRF(Cross-site request forgery 跨站请求伪造) 原理：即网站B伪造一个网站A的接口链接引诱用户点击，获取受害用户对应网站A的cookie(用户曾登录过)。 防御： Token验证：点击引诱链接只会泄露cookie而不会泄露Token Referer验证：页面来源验证，阻止其他站点的操作，但是可以伪造 隐藏令牌：隐藏性的Token 验证码(缺点是影响用户体验) XSS(cross-site scripting 跨站脚本攻击)原理：不需要登录认证，只需要向页面注入JS攻击脚本反射型：发出请求时，XSS代码出现在URL中，作为输入提偶叫道服务器端，服务器端解析后响应，XSS代码随着响应内容一起回传给浏览器，最后浏览器解析执行XSS代码。 存储型：与反射型XSS区别在于，存储型XSS提交的代码会存储在服务器端(数据库，内存，文件系统等)，下次请求目标页面时不用再次提交XSS代码。 防御：让插入的XSS不可执行 编码：十进制编码，转义字符编码等 过滤：移除用户上传的DOM属性，如onerror等。移除用户上传的Style、Script、Iframe等节点。 校正：避免对HTML直接解码。使用DOM Parse转换，校正不匹配的DOM标签 cookie:如果使用了cookie,要设置成http-only防止客户端篡改]]></content>
      <categories>
        <category>前端</category>
        <category>前端-Web安全防护</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端笔记（CSS）：CSS的覆盖]]></title>
    <url>%2F2017%2F10%2F29%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%EF%BC%88CSS%EF%BC%89%EF%BC%9ACSS%E7%9A%84%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[在页面中，我们常用id、class以及内联样式表来设置我们的组件CSS 有时候我们为了编码的简便会使用CSS库，这些库会设置好全局的CSS，但是有某几个组件我们不想使用CSS库中定义的样式而想用别的特别的样式怎么办呢？ 解决方法就是：使用自定的CSS样式覆盖之前的CSS样式 CSS中的优先级大体是：内联样式&gt;id引用&gt;class、伪类、属性选择器引用&gt;类型选择器、伪元素选择器引用，当优先类型相同时，数量较多的属性优先级较高。 特殊性排行：12345678910//选择器 类型(由低到高)style="" 1,0,0,0#test1 #test2 &#123;&#125; 0,2,0,0#content .date &#123;&#125; 0,1,1,0div#content &#123;&#125; 0,1,0,1#content &#123;&#125; 0,1,0,0p.comment .date &#123;&#125; 0,0,2,1p.comment &#123;&#125; 0,0,1,1div p &#123;&#125; 0,0,0,2p &#123;&#125; 0,0,0,1 举个例子，比如下面这个style： 1234567891011121314body &#123;background-color: black;font-family: Monospace;color: green; &#125; #orange-text &#123;color: orange; &#125; .class1 &#123;color: pink ; &#125; .class2 &#123; color: blue; &#125; 我们来创建一个段落加上点文本看看字体颜色会发生什么变化 &lt;p&gt;Hello World!&lt;/p&gt;，首先不指定id和class，字体默认为body中的样式，为green class需要特别讲一下：比如这段代码&lt;p class=&quot;class1 class2&quot; &gt;Hello World!&lt;/p&gt;这段文本会同时继承class1、class2中的样式，但是当这两个类中有相同的变量时，class间有冲突时，优先使用后者的定义，所以此时文本字体为blue。 &lt;p class=&quot;class1 class2&quot; id=&quot;orange-text&quot;&gt;Hello World!&lt;/p&gt; 此时id覆盖class，文本字体为orange。 &lt;p class=&quot;class1 class2&quot; id=&quot;orange-text&quot; style=&quot;color:whitle&quot;&gt;Hello World!&lt;/p&gt; 此时内联样式表覆盖id和class，文本字体为white。 如果你想某个样式的某个变量不被覆盖的话，可以在其后面加上！important来强制增加其的优先级，但是只能加在id、class中。比如在#orange-text中的color后面加上！important：123456#orange-text &#123; color: orange ！important ; &#125; &lt;p class="class1 class2" id="orange-text" style="color:whitle"&gt;Hello World!&lt;/p&gt; 这样的话就算有内联样式表设置color为white，color仍然为orange。 当优先类型相同时，数量较多的属性优先级较高，比如：12345678910#test1 #test2 &#123; color:red;&#125;div #test2&#123; color:black;&#125;&lt;div id=&quot;test1&quot;&gt;&lt;h1 id=&quot;test2&quot;&gt;Test&lt;/h1&gt;&lt;/div&gt; 页面中的h1应为红色，因为red属性有两个id，而black属性只有一个id选择器和一个类型选择器。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows下用Git/Github托管代码]]></title>
    <url>%2F2017%2F10%2F02%2FWindows%E4%B8%8B%E7%94%A8Git-Github%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[写在前面 : 摘自第一行代码，仅用作学习 一、访问 : https://git-for-windows.github.io/ 下载git for windows 二、打开Git Bash配置下身份： 12git config --global user.name &quot;Tony&quot;git config --golbal user.email &quot;tony@gmail.com&quot; 验证是否创建成功：仅需将用户名和邮箱去掉12git config --global user.name git config --golbal user.email 若创建成功则会打印出刚才创建的用户名和邮箱 三、创建代码仓库 进入到项目文件夹： 1cd 项目文件夹位置 在这个目录下输入命令： 1git init 仓库创建完成后会在项目文件夹下生成一个隐藏的.Git文件夹，用于记录本地所有Git操作，可以通过ls -al命令来查看，如果想删除本地仓库直接删除这个隐藏文件夹就好了 四、提交本地代码 添加想要提交的某个文件/某个目录/全部文件分别对应： 1git add 文件名 / git add 目录名 / git add . 提交文件： 1git commit -m &quot;first commit.&quot; 后面的描述信息可以任意更改，但一定要有。 五、创建和选择分支 创建：git branch 分支名 选择分支：git checkout 分支名 将分支一的代码合并到主支上： 12git checkout mastergit merge 分支一 删除分支：git branch -D 分支名 六、将代码托管到Github上 在github上创建完项目后，用Git Bush进入到本地的文件夹，init以后，将github上的项目克隆到本地： 1git clone &lt;github地址&gt; 将克隆下来的.gitgnore、LICENSE、README.md、.git这四个文件放到本项目文件夹中，覆盖原有项目。 接着提交就好了： 123git add .git commit -m &quot;First conmit.&quot;git push origin master]]></content>
      <categories>
        <category>Git/Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android端用JDBC远程连接服务端Mysql数据库]]></title>
    <url>%2F2017%2F09%2F14%2FAndroid%E7%AB%AF%E7%94%A8JDBC%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AFMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[转自：http://blog.csdn.net/yuanzeyao/article/details/38777557 在学习android连接Mysql 数据库前，我们先来复习一下java如何通过jdbc连接MysqlJDBC程序开发的几个步骤: 0、在工程的libs文件夹下放置jar包按照：Project Structure — Denpendencies — + — Jar dependency 的步骤导入jar包到工程里jar包下载地址：http://download.csdn.net/download/qq_36113598/9979455 1、注册驱动程序1Class.forName("com.mysql.jdbc.Driver"); JAVA规范中明确规定：所有的驱动程序必须在静态初始化代码块中将驱动注册到驱动程序管理器中。 2、建立数据库连接对象(Connection)1Connection conn=DriverManager.getConnection("jdbc:mysql://192.168.8.21:3306/test", "User", "Pasword"); 3、创建Statement对象1Statement stm = con.createStatement(); 4、发送SQL语句12stm.executeUpdate(); stm.executeQuery(); 5、如果有结果集，处理结果集(ResultSet) 6、关闭相应的流资源 那么开始在android中开始通过Jdbc连接Mysql数据库吧 12345678910111213141516171819202122232425262728293031323334353637public void onClickQuery(View view) &#123; //在android中操作数据库最好在子线程中执行，否则可能会报异常 new Thread() &#123; public void run() &#123; try &#123; //注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://10.0.2.2:3306/gjun&quot;; Connection conn = DriverManager.getConnection(url, &quot;root&quot;, &quot;gavin&quot;); Statement stmt = conn.createStatement(); String sql = &quot;select * from t_user&quot;; ResultSet rs = stmt.executeQuery(sql); while (rs.next()) &#123; //处理结果集 &#125; rs.close(); stmt.close(); conn.close(); Log.v(&quot;final&quot;, &quot;success to connect!&quot;); &#125; catch(ClassNotFoundException e) &#123; Log.v(&quot;final&quot;, &quot;fail to connect!&quot;+&quot; &quot;+e.getMessage()); &#125; catch (SQLException e) &#123; Log.v(&quot;final&quot;, &quot;fail to connect!&quot;+&quot; &quot;+e.getMessage()); &#125; &#125;; &#125;.start();&#125; 注意，我是在模拟器上运行的，如果在真机上运行，那么Ip地址就需要换成真实Ip地址，在虚拟机中，10.0.2.2指的就是寄主电脑的Ip地址 在运行过程中一定要注意： 1、关闭本机防火墙(不一定需要) 2、在Manifest中加入网络访问权限android.permission.INTERNET 3、服务端mysql数据库允许外部远程用户访问]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用OkHttp]]></title>
    <url>%2F2017%2F09%2F08%2F%E4%BD%BF%E7%94%A8OkHttp%2F</url>
    <content type="text"><![CDATA[写在最前面：用于个人学习，资料来源于《第一行代码》（郭霖 著）和 OkHttp教程 1. 首先添加OkHttp库的依赖在app/build.gradle里的dependencies闭包里加入最新版本的okhttp依赖 12345dependencies &#123; ...(省略部分) compile &apos;com.squareup.okhttp3:okhttp:3.7.0&apos; ...&#125; 或者在File-Project Structure-app-denpendencies里从网上导入相应的依赖 2. 创建一个OkHttp实例1OkHttpClient client = new OkHttpClient(); 3. 创建一个Request对象123Request request = new Request.Builder().url(&quot;网址&quot;) //或者调用String变量.build(); 4.调用同步/异步方法来发送请求并获取服务器返回数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//同步方法:Response response = client.newcall(request).execute();//异步方法:client.newCall(request).enqueue(callback); //callback即为返回数据载体//完整代码(同步)： private void sendRequestWithOkHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;网址&quot;) .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; //完整代码(异步)：private void sendRequestWithOkHttp(okhttp3.Callback callback)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;网址&quot;) .build(); client.newCall(request).enqueue(callback); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;//在调用的时候要重写两个方法：sendRequestWithOkHttp( new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //do &#125;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; final String responseText =zresponse.body().string(); //返回的json数据 &#125; &#125;)]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用Gson解析Json数据的一些知识储备]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%88%A9%E7%94%A8Gson%E8%A7%A3%E6%9E%90Json%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1、利用GsonFormat直接创建JSON语句对应的JavaBean 2、由于JSON语句里不能使用大写解析出的JavaBean变量名全为小写，而有时我们需要将部分变量名改为大写或其他名字，可使用如下方法： 123@SerializedName(&quot;n&quot;)private String userName; //将Json传回来的n更改为userName； 3、使用Gson解析Json语句，生成实体类（比如下面的News类） 1234public static News parseJsonWithGson(final String requestText)&#123; Gson gson = new Gson(); return gson.fromJson(requestText, News.class); &#125; 调用这个方法以后就会生成Json对应的JavaBean了，接下来就可以愉快的调用里面的参数啦，当然前提是要导入了Gson的包，如：compile ‘com.google.code.gson:gson:2.8.0’，最新的依赖包请执行查询。 4、完整流程展示： 首先，从api获取Json数据如下： 然后，用Gsonformat解析出对应的JavaBean： 接着调用Gson，生成对应实体： 12final NList nlist = Utility.parseJsonWithGsonN(responseText); //用Gson处理javaon数据，并传回NewsList实例中 最后根据JavaBean的结构愉快地调用nlist里面的内容就好啦~]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
