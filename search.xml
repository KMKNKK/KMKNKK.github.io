<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[不定期更新的图文]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%AF%8F%E6%97%A5%E5%9B%BE%E6%96%87%2F</url>
    <content type="text"><![CDATA[&nbsp;这几天把之前积累的零碎知识点好好归类总结一下2018 / 02 / 21&nbsp;永新&nbsp;阴&nbsp;学Webpack有种在Window配环境变量的既视感= =2018 / 02 / 18&nbsp;永新&nbsp;晴&nbsp;昨天拍的初雪，和小五一样好看。2018 / 01 / 05&nbsp;南京&nbsp;晴&nbsp;甜甜甜甜甜 2018 / 01 / 01&nbsp;南京&nbsp;多云&nbsp;&nbsp;今天没啥特别的话，&nbsp;就是想发一下这张好看的图:)2017 / 12 / 29&nbsp;南京&nbsp;小雨&nbsp;怀念躺在沙漠里，&nbsp;看流星的那一夜。2017 / 12 / 28&nbsp;南京&nbsp;小雨&nbsp;不管你愿不愿意，&nbsp;时间它就这么滴答滴答地流逝了。&nbsp;所以少年啊，快点去创造奇迹吧！2017 / 12 / 26&nbsp;南京&nbsp;晴念念不忘，必有回响。&nbsp;考研的师兄师姐们加油！2017 / 12 / 22&nbsp;南京&nbsp;晴&nbsp;Stay foolish,stay hungryand&nbsp;Keep going…2017 / 12 / 18&nbsp;南京&nbsp;晴&nbsp;你没病，也很棒，别妄自菲薄2017 / 12 / 12&nbsp;南京&nbsp;又一个很棒的晴天&nbsp;有两种药包治百病：时间和沉默。2017 / 12 / 08&nbsp;南京&nbsp;大大大大晴天&nbsp;怎样都好，只是别停下前进的步伐。2017 / 12 / 07&nbsp;南京&nbsp;多云&nbsp;考完编译原理，又可以开心地造轮子了。2017 / 12 / 06&nbsp;南京&nbsp;晴&nbsp;希望每一个孩子都能被善待。2017 / 11 / 30&nbsp;南京&nbsp;小雨&nbsp;无卿之晨，朝也昏昏。2017 / 11 / 29&nbsp;南京&nbsp;小雨&nbsp;&nbsp;往事皆成诗。2017 / 11 / 28&nbsp;南京&nbsp;多云]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML小知识汇总]]></title>
    <url>%2F2018%2F02%2F21%2FHTML%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. 标签 &lt;a&gt;中不能再嵌套&lt;a&gt; &lt;ul&gt;中嵌套&lt;li&gt;构成无序列表 Unorderlist &lt;ol&gt;中嵌套&lt;li&gt;构成有序列表 Orderlist &lt;dl&gt;标签定义一个描述列表，与&lt;dt&gt;(定义项目名字)和&lt;dd&gt;(描述项目)一起使用 用法：(&lt;dt&gt;和&lt;dd&gt;可为任意个)1234&lt;dl&gt; &lt;dt&gt;Firefox&lt;/dt&gt; &lt;dd&gt;A free, open source, cross-platform, graphical web browser&lt;/dd&gt;&lt;/dl&gt; 2. HTML5中新的表单元素 datalist : 规定输入域的选项列表,类似于下拉框 123456789&lt;input list="browsers" id="myBrowser" name="myBrowser" /&gt;&lt;datalist id="browsers"&gt; &lt;option value="Chrome"&gt; &lt;option value="Firefox"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt; &lt;option value="Microsoft Edge"&gt;&lt;/datalist&gt; output : 用于不同类型的输出 12345&lt;form oninput="result.value=parseInt(a.value)+parseInt(b.value)"&gt; &lt;input type="range" name="b" value="50" /&gt; + &lt;input type="number" name="a" value="10" /&gt; = &lt;output name="result"&gt;60&lt;/output&gt;&lt;/form&gt; keygen : 用于验证用户，但是已移出标准 3.置换元素 置换元素：浏览器根据元素的标签内容，来决定元素具体显示的内容常见的置换元素有：&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt; 不可置换元素：内容直接表现给客户端（如浏览器）常见的不可置换元素有：&lt;label&gt;、&lt;a&gt; 等]]></content>
      <categories>
        <category>前端</category>
        <category>前端-HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS小知识汇总]]></title>
    <url>%2F2018%2F02%2F21%2FCSS%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. link和@import的区别 (1) link属于HTML标签，而@import由CSS提供 (2) 页面加载时，link会同时被加载，而@import引用的CSS会等到页面加载完时再加载 (3) import的IE版本要求为&gt;IE5，而link无兼容问题 2. 盒模型 盒模型包括： 内容(content),填充(padding),边界(margin),边框(border) 盒模型有两种：IE盒模型和W3C盒模型，如果DOCTYPE缺失，在ie6，ie7，ie8下会触发IE盒模型 W3C盒模型： box-sizing:content-box; width/height = content IE盒模型 ： box-sizing:border-box; width/height = border + padding + content 3. repaint和reflow repaint(重绘)：repaint发生更改时，元素外观被改变，且在没有改变布局的情况下发生，如改变outline，visibility，background color，不会影响到dom结构。 reflow (渲染)：与repaint区别就是他会影响dom的结构渲染，同时他会触发repaint，他会改变他本身与所有父辈元素(祖先)，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。 如：display:none会触发reflow和repaint，而visibility:hidden只会产生repaint 4. 字体相关的CSS (1) text-transform : capitalize 首字母大写 (2) text-transform : lowercase 小写 (3) text-transform : uppercase 大写 (4) font-weight : bold 粗体 (5) font-weight : bolder 更粗 (6) font-weight : lighter 细体 (7) font-style : italic 斜体]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git一些小tips]]></title>
    <url>%2F2018%2F02%2F18%2Fgit%2F</url>
    <content type="text"><![CDATA[最近在和好基友用Github练习共同开发，期间发现了一些问题和一些有用的Tips，在这里挑一些比较有有用/有意思的小小总结一下。 问题:起初没啥经验，.gitignore总是空空白白的，导致Git的文件过于冗余。 并且很致命的一点是这会导致上传一些没必要的配置文件，而由于电脑环境变量或者轮子版本的不同，很可能会导致编译错误= =解决方法：丰富.gitignore 文件，遵守Github规范```js See http://help.github.com/ignore-files/ for more about ignoring files.compiled output/dist/tmp dependencies/node_modules IDEs and editors/.idea.project.classpath.c9/.launch.settings/ .sublime-workspace IDE - VSCode.vscode/*!.vscode/settings.json!.vscode/tasks.json!.vscode/launch.json!.vscode/extensions.json misc/.sass-cache/connect.lock/coverage/*/libpeerconnection.lognpm-debug.logtestem.log/typings e2e/e2e/.js/e2e/.map #System Files.DS_StoreThumbs.db```js 小Tips：在提交到Github的时候，我们需要写一些信息来介绍一下这次提交。不仅是提醒自己，同样也使得其他开发者和用户能够更清楚地了解项目动向。所以一个清晰地Summary就显得比较重要了。 在这里介绍一种增加Summary可读性的方法：加入emoji 这不仅使得commit的Summary更加美观、具有可读性，而且在遵循emoji使用规范的前提下，能使得读者更易了解commit的内容。 效果如图： 以下为常用emoji使用规范，查看完整文档。]]></content>
      <categories>
        <category>Git/Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IM即时聊天室（三）：项目详解及源码分析]]></title>
    <url>%2F2018%2F02%2F02%2FIM%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[之前我们在 IM即时聊天室（一）：WebSocket 和 IM即时聊天室（二）: Socket.io + Node.js 两篇文章中介绍了搭建一个IM的所需的技术栈和通信原理。那在这篇文章里我们就来详细说一下具体的应用并提供完整源码。 PS: 这是我网络编程课的一个小作业，因为博主比较懒所以这篇文章的大部分由我的课程报告组成（逃） 实现目标应用实例是一个多人聊天室程序，用户可以通过指定服务器IP进入聊天室和聊天室内其他用户进行聊天，聊天室的功能主要有文本、表情和图片传输，并在Web界面中显示。 需求分析 应用采用客户/服务器模式，分为客户端程序和服务器端程序。 用户通过客户端可以选择头像，发送信息、表情、图片 服务端可以同时接收多个客户端信息，并根据需求进行转发、广播或者回传给客户端特定的消息。 客户端程序和服务器程序通过网络交换聊天的字符串内容（其中表情和头像为特殊格式代码，图片为转码后获得的URL格式） 话不多说，先看程序效果展示： 技术实现 通信协议选择Balabalabala… 详见下面两篇文章IM即时聊天室（一）：WebSocketIM即时聊天室（二）：Socket.io + Node.js 客户端UI界面：HTML+CSS+Bootstrap自适应 界面交互：原生Javascript+jQuery 消息的发送和接收：Socket.io PS：由于客户端代码太太太太太多了，我只挑比较有特点的的讲一下 登录啥的就不讲了，大概思路就是开始时隐藏聊天界面，登录成功后隐藏登录界面显出聊天界面，源码里有完整的注释 先贴一下客户端代码大致结构图： 比较有意思的代码是我仿照微信做了一个回到最新消息处的功能。 当我们在聊天时，我们会希望最新的消息实时显示出来，但是当我们在看历史消息时，可不希望被强行定位到最新消息处。并且在查看历史消息时，可以通过按钮回到最新消息处。 于是我们就要判断用户在查看历史消息还是正在聊天，方法就是判断最新的消息是否出现在了用户窗口里。 关键代码： 123456789101112131415161718192021222324252627282930313233/*将页面下拉到最新消息处*/ function scrollToEnd()&#123; var div = document.getElementsByTagName("div"); div_length = div.length-4; div[div_length].scrollIntoView(&#123;behavior: "smooth"&#125;); //平滑滚动，提高了用户体验 &#125; /*判断当有新信息来时，用户是否在页面底端*/ function isNewInWindow()&#123; var div = document.getElementsByTagName("div"); div_length = div.length-5; if(isInWindow(div[div_length]))&#123; return true; &#125; return false; &#125; /*判定元素是否在界面内*/ function isInWindow(x)&#123; if(x.getBoundingClientRect().top &gt; window.innerHeight)&#123; console.log("down"); return false; &#125; else if(x.getBoundingClientRect().bottom &lt; 0)&#123; console.log("up"); return false; &#125; return true; &#125; 服务端服务端主要使用了Node.js+Socket.io来构建服务端，需要Node环境来运行。 主要的思路：请求HTTP服务 → 在此基础上使用WebSocket → 引入Socket.io模块并创建实例 → 用该实例进行socket监听 → 通过socket进行消息的发送、转发、群发等。 服务端关键代码： 12345678910var app = require('http').createServer();var io = require('socket.io')(app);var PORT = 8081;/*定义用户数组*/var users = [];app.listen(PORT);io.on('connection',function (socket) &#123; //监听 //发送、转发、群发消息&#125;) 图片文件传输 图片传输部分我本来是想用Base64编码，先在客户端读取图片二进制信息并编成Base64格式发送给服务端，服务端转发后别的客户端接收后解码。 但是后面放弃了这一方式，因为直接传输二进制信息太慢了，于是改用了HTML5的Filereader方法。 这个方法有个优点就是其中的readAsDataURL函数可以直接将图片二进制信息转成URL格式，这样子我只用发送并转发一个简短的URL，客户端直接根据URL加载图片，省去了大量传输和解码时间。 关键代码： 12345678910111213141516171819202122//图片发送document.getElementById('sendImage').addEventListener('change', function() &#123;//检查是否有文件被选中if (this.files.length != 0) &#123;//获取文件并用FileReader进行读取var file = this.files[0],reader = new FileReader();if (!reader) &#123;return;&#125;;reader.onload = function(e) &#123;//读取成功，发送到服务器socket.emit('sendImg',&#123;username:uname,image: e.target.result,date:new Date().toTimeString().substr(0, 8),headnum:headnum&#125;);&#125;;reader.readAsDataURL(file);&#125;;&#125;, false); 头像选择/表情包传输头像和表情已经预先放置在客户端中，用户在选择以后将产生特定格式的代码，放置到要发送的信息当中。 别的客户端接收到的消息时候，先用正则表达式检索信息中是否存在该格式代码，若有则加载相应的头像/表情，以达到效果。 关键代码，以表情为例： 123456789101112//emojidocument.getElementById('emojiWrapper').addEventListener('click', function(e) &#123;//获取被点击的对象var target = e.target;console.log(target);if (target.nodeName.toLowerCase() == 'img') &#123; //如果是表情图像则发送var sendtxt = document.getElementById('sendtxt');sendtxt.focus();sendtxt.value = sendtxt.value + '[emoji:' + target.num + ']';&#125;;&#125;, false); 源码Gitbub地址：https://github.com/KMKNKK/Chatroom-WebSocket/tree/homework注意是homework的branch如果有疑问欢迎来问我~QQ：895025751 Wechat：kk-dm506 重要文件结构： │ ├─index.html //客户端 │ ├─css │ bg.jpg //背景图 │ chat.css │ ├─images //图片资源 │ │ logo.png │ │ toNewMessage.png │ │ │ ├─emoji //表情 │ │ │ └─user //头像 │ │ ├─js │ │ app.js //服务端JS │ │ chat.js //客户端JS │ │ jquery.min.js //依赖 │ │ socket.io.js //依赖 │ │ │ └─.vscode │ settings.json │ ├─new //BootStrap和jQuery文件 │ │ jquery-3.2.1.min.js │ │ │ └─bootstrap-3.3.7-dist │ │ └─node_modules //依赖文件]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL四种匹配模式]]></title>
    <url>%2F2018%2F01%2F25%2FSQL%E5%9B%9B%E7%A7%8D%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[SQL提供了四种匹配模式：% _ [ ] [^ ] 1. %%表示模糊匹配0或多个字符，如以下查询语句：select * from user where name like &#39;%三%&#39;; 这个语句将会把name中带有“三”的信息全部查找出来select * from user where name like &#39;%三&#39; ; 这个语句将会把name中最右边带有“三”的信息全部查找出来select * from user where name like &#39;三%&#39; ; 这个语句将会把name中最左边带有“三”的信息全部查找出来 2. __表示任意单个字符，如以下语句: select * from user where name like &#39;_三_&#39;; 这个语句会匹配出“二三四” select * from user where name like &#39;__三&#39;; 这个语句会匹配出“一二三” 3. [ ][ ]表示括号内所列字符中的一个（类似于正则表达式），如以下语句：select * from user where name like &#39;老[大二三]&#39;; 如果都存在的话将找出“老大”、“老二”、“老三”同时支持缩写0-9、a-z等。 4.[^ ][^ ]类似于正则表达式，将括号内的元素排除，如以下语句：select * from user where name like &#39;[0-3]个&#39; 将会检索出除了“0个”，“1个”，“2个”，“3个”]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML常用头部标签]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%B8%B8%E7%94%A8%E5%A4%B4%E9%83%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[基本标签1&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML doctype，不区分大小写 --&gt; 1&lt;meta charset='utf-8'&gt; &lt;!-- 声明文档使用的字符编码 --&gt; 12345&lt;html lang="zh-CN"&gt; &lt;!-- 页面采用中文（中国大陆范围，包括各种方言、繁体、简体等） --&gt;&lt;html lang="zh-cmn-Hans"&gt; &lt;!-- 简体中文（世界范围） --&gt;&lt;html lang="zh-cmn-Hant"&gt; &lt;!-- 繁体中文 --&gt;&lt;html lang="en-US"&gt; &lt;!-- 页面采用英文 --&gt; 1234&lt;title&gt;页面标题&lt;/title&gt;&lt;meta name="descirption"&gt; content="不超过150个字符"&gt; &lt;!-- 页面描述 --&gt;&lt;meta name="keywords" content="VPN"&gt; &lt;!-- 页面关键词 --&gt;&lt;meta name="author" content="name,email@gmail.com"&gt; &lt;!-- 网页作者 --&gt; 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;!-- 使用IE最新版本渲染页面，若有chrome则优先使用chrome --&gt; 可选标签1&lt;base target="_blank"/&gt; &lt;!-- 设定页面中链接都在新窗口打开，默认为_self（在相同框架中打开） --&gt; 1&lt;meta http-equiv="Refresh" content="5;url=xxx"/&gt; &lt;!-- 在5秒后重新定向到指定链接 --&gt; 1&lt;meta name="renderer" content="webkit"&gt; &lt;!-- 当为双核浏览器时，优先使用webkit渲染 --&gt; 1&lt;link rel="dns-prefetch" herf="xxx"&gt; &lt;!-- dns预解析，提升图片加载速度，提升网站性能 --&gt; 移动设备123456789&lt;meta name="viewport" content="width=device-width,initial-scale=1,maximun-scale=1,userscalable=no"&gt;/***其中 width=device-width 自适应容器宽度* initial-scale 初始化缩放比例* minimum-scale 最小缩放比例* maximum-scale 最大缩放比例* user-scalable=no 禁止用户缩放*当user-scalable=no时，用户无法缩放，可以使得WebAPP更像原生应用*/]]></content>
      <categories>
        <category>前端</category>
        <category>前端-HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象创建的七种方式]]></title>
    <url>%2F2018%2F01%2F15%2F%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近在复习红宝书，里面介绍了对象创建的七种方式，分别是： 工厂模式 构造函数模式 原型模式 构造函数和原型组合模式 动态原型模式 寄生构造模式 稳妥构造模式 在这里总结一下，以便归纳学习。 工厂模式工厂模式通过函数接收参数来封装创建对象。包括以下步骤： 1.创建封装函数2.显示地创建对象3.将接收的参数和方法赋值给该对象4.将创建的对象返回给实例 如下面例子：12345678910111213function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson("Sam", 20, "Software Engineer");var person2 = createPerson("Jack", 24, "Doctor"); 构造函数模式构造函数（constructor）方法与工厂模式有所不同，表现在： 1.没有在函数里显示地创建对象2.直接将属性和方法赋值给了this对象3.没有return语句4.构造函数名称首字母应大写 创建Person的新实例，必须使用new操作符。以这种方式调用构造函数会经历以下四个步骤：（1）创建一个新对象（2）将构造函数的作用域赋给新对象（于是this指向这个新对象）（3）执行构造函数中的代码（为该对象添加属性）（4）返回新对象给实例1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person("Sam", 20, "Software Engineer");var person2 = new Person("Jack", 24, "Doctor"); 上面这种写法有一个缺点，就是由于作用域链的关系，每实例化一次Person构造函数都会创建一个新的sayName函数。两个实例中的同名实际上是两个独立开的函数，会造成不必要的开销。1alert(person1.sayName === person2.sayName); //false 因此我们可以像这样吧函数定义转移到构造函数之外：12345678910111213141516function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName() &#123; alert(this.name);&#125;var person1 = new Person("Sam", 20, "Software Engineer");var person2 = new Person("Jack", 24, "Doctor");//此时两个实例共享一个全局函数alert(person1.sayName === person2.sayName); //true 当然构造函数本质其实也是函数，你也可以把它当做普通函数来使用：12345678//作为普通函数调用Person("Greg", 27, "Doctor"); //添加到windowwindow.sayName(); //"Gray"//在另一个对象的作用域中调用var o = new Object();Person.call(o, "Kristen", 25, "Nurse");o.sayName(); //"Kristen" 原型模式&emsp;&emsp;我们创建的没一个函数都有一个原型（prototype）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。&emsp;&emsp;使用原型对象的好处是我们不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象当中。12345678910111213141516function Person() &#123;&#125;Person.prototype.name = "Sam";Person.prototype.age = 20;Person.prototype.job = "Software Engineer";Person.prototype.sayName = funtion() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // "Sam"var person2 = new Person();person2.sayName(); // "Sam"person1.sayName = person2.sayName // true 在创建实例时，我们仍然可以用new方法来实例对象，但是新的实例的属性和方法是共享的。 构造函数和原型函数结合这种方式集两种模式之长，每个实例都会有自己的一份构造函数中的实例属性副本，同时又共享着原型中的方法。12345678910111213function Person(name, age, job) &#123; //每个实例独有 this.name = name; this.age = age; this.job = job; this.friends = ["Shelby","Court"];&#125;Person.prototype = &#123; //共享的方法 constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125; 动态原型模式这个方法简单的来说就是先将所有信息封装在构造函数中，然后通过判断说需要的函数是否存在来动态地初始化原型。12345678910111213function Person(name, age, job) &#123; //属性 this.name = name； this.age = age; this.job = job; //方法 if(typeof this.sayName != "function") &#123; //不存在这个函数 Person.prototype.sayName = function() &#123; alert(this.name); &#125; &#125;&#125; 寄生构造函数模式简单的来说就是：构造模式的外表 + 工厂模式的内心这个方法用于在特殊情况下为对象创建构造函数。如：想创建一个具有自定方法的数组。由于无法直接更改数组的构造函数，可以用寄生构造方法来封装一个所需函数：12345678910111213141516function SpecialArray() &#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments)； //添加方法 values.toPipedString = function() &#123; return this.join("|"); &#125;; return values;&#125; var friend = new Person("Nicholas", 29, "Writer");friend.sayName(); //"Nicholas" 稳妥构造函数模式在安全环境下，不使用new和this12345678910111213function Person(name, age, job) &#123; var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); &#125;; return o;&#125;//在这个稳妥方法中，除了sayName()以外没有方法访问到name属性]]></content>
      <categories>
        <category>前端</category>
        <category>前端-JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS:元素和基本定位]]></title>
    <url>%2F2018%2F01%2F05%2FCSS-%E5%85%83%E7%B4%A0%E5%92%8C%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[元素块级元素(disply：block)：p、h1、div等元素，这些元素显示为一块内容，即”块框”。 行内元素(display：inline)：strong、span等元素，这些内容显示在行中，即”行内框”。 行内盒元素（display：inline-block）：顾名思义，这个定义使得元素像行内元素一样水平依次排列，但是框的内容仍然符合块级框的行为，例如可以显示地设置宽度、高度、垂直外边距和内边距。 我们可以使用dispaly来更改元素的类型：12345display:block //使行内元素表现的像块级元素一样display:inline //默认值，像行内元素一样显示display:inline-block //行内盒元素display:list-item //像列表项一样显示display:none //使这个框的内容不显示，不占用文档空间 CSS中的基本定位方式 普通流 浮动 绝对定位（position：absolute） 相对定位（position：relative） 固定定位（position：fixed） 继承定位（position：inherit） 默认定位/无定位（position：static） 1、普通流 除非专门指定，否则所有框均在普通流中定位普通流中元素框的的位置由元素在HTML中的位置决定 块级框从上到下一个接一个垂直排列，垂直距离由垂直外边距决定，可能会发生margin合并现象。 行内框在一行中水平排列，可以使用水平内边距、边框、外边距来调整它们的水平间距。但是垂直外边距、边框、外边框并不会影响行内框的高度。在行内框上设置显式地高度和宽度也没有影响。 由一行形成的水平框成为行框，行框的高度总是足以容纳其包含的所有行内框。即：行框高 = Max(所含行内框的高)可以通过设置行高进而间接(在视觉上)增加行内框的高度。 2、浮动 浮动不占据文档流的空间，但是文本会会环绕在浮动元素周围，可能会覆盖掉文档流元素。 浮动图解:框1脱离文档流向右浮动直到碰到边界：浮动元素之间会相互影响：文本环绕在浮动元素周围：可以通过给文本元素增加clear属性（left、right、both、none）来表示哪边不应该挨着浮动框以达到上图左边的效果。 清除浮动： overflow:hidden 这个方法可以清除浮动，但会产生BFC，强制包裹住元素，导致内容被截断或产生滚动条。 clear类方法(推荐)1234567.clear:after &#123; content: "."; height: 0; visibility: hidden; display: block; clear: both;&#125; 3、绝对定位 12345#myBox &#123; position: absolute; left: 20px; top: 20px;&#125; 绝对定位使元素位置与文档流无关，因此不占据文档空间。普通文档流元素就当绝对定位元素不存在一样。 4、相对定位 12345#myBox &#123; position: relative; left: 20px; top: 20px;&#125; 在使用相对定位时，无论是否移动，元素仍然占据原来的空间（占据文档空间）。因此，移动元素会导致覆盖其他框。 5、固定定位1position: fixed; 将元素从文档流中移除，使元素固定在窗口某一位置不动，并且跟随页面滚动始终处于页面固定的位置。 6、继承定位1position: inherit; 顾名思义，从父类元素继承定位属性。 7、默认值1position: static; 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js 读写文件]]></title>
    <url>%2F2017%2F12%2F27%2FNode-js-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言：本文大部分都是廖雪峰老师的教程内容，自己对其中的一些知识进行了总结和梳理。不对之处还望指正这篇blog主要作为我自己的知识储备吧，所以没有用很多的话来解释，只详写到自己能懂为止。 在看这篇文章之前，我觉得你需要对JavaScript中的Buffer对象和同步异步有所了解。 关于Buffer对象，我推荐阮一峰老师的这一篇：Buffer对象 而同步异步我推荐你去看看掘金上的一篇文章：这一次，彻底弄懂JavaScript执行机制，不局限与同步异步，非常值得一看。 模块导入我们要读写文件，首先要导入Node.js内置的fs模块即文件系统模块(类似于JAVA里面的包或者类，里面封装了方法) 123'use strict'var fs = require('fs'); 读文件 异步方法:1234567891011'use strict'var fs = require('fs');fs.readFile('test.txt','utf-8',function(err,data) &#123; //读取文本文件 if(err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 这个方法包含三个参数：文件索引地址、编码格式、回调函数。其中回调函数接收两个参数，错误对象err和读取的数据data。 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）：12345678fs.readFile('sample.png', function (err, data) &#123; //读取二进制文件 if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + ' bytes'); &#125;&#125;); Buffer对象和String之间可以相互转化：12345//Buffer -&gt; Stringvar text = data.toString('utf-8');//String -&gt; Buffervar buf = Buffer.from(text,'utf-8'); 同步方法： 123456'use strict';var fs = require('fs');var data = fs.readFileSync('sample.txt', 'utf-8');console.log(data); 相比于异步函数，多了Sync(同时、同步)后缀，不接受回调函数。函数直接返回结果，需要用try...catch来捕获错误：123456try&#123; var data = fs.readFileSync('test.txt','utf-8'); console.log(data);&#125; catch(err) &#123; console.log(err);&#125; 写文件大体原理与读文件类似，这里就不赘述了,需要注意的是跟python一样，JS的写入会覆盖掉先前存在的文本。贴一下大体代码：1234567891011121314151617'use strict';var fs = require('fs');var data = 'Hello';//异步方法，接受参数：文件索引地址、数据、回调函数。传入String则默认按UTF-8编码。fs.writeFile('test.txt',data,function(err)&#123; if(err) &#123; console.log(err); &#125; else&#123; console.log('ok.'); &#125;&#125;);//同步方法fs.writeFileSync('test.txt',data); 博主在测试中发现，当同时进行异步读写时，无论两者的函数谁在前，都会先执行写的操作。 文件状态如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：1234567891011121314151617181920212223242526'use strict';var fs = require('fs');//异步实现fs.stat('sample.txt', function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); &#125; &#125;&#125;);//同步实现var stat = fs.statSync('test.txt'); Stream流方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546'use strict';var fs = require('fs');// 打开一个读取流:var rs = fs.createReadStream('sample.txt', 'utf-8');rs.on('data', function (chunk) &#123; console.log('DATA:') console.log(chunk);&#125;);rs.on('end', function () &#123; console.log('END');&#125;);rs.on('error', function (err) &#123; console.log('ERROR: ' + err);&#125;);//打开一个写入流：var ws1 = fs.createWriteStream('output1.txt', 'utf-8');ws1.write('使用Stream写入文本数据...\n');ws1.write('END.');ws1.end();var ws2 = fs.createWriteStream('output2.txt');ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));ws2.write(new Buffer('END.', 'utf-8'));ws2.end();//pipe//在Node.js中，Readable流有一个pipe()方法，可以把一个文件流和另一个文件流串起来//这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：'use strict';var fs = require('fs');var rs = fs.createReadStream('sample.txt');var ws = fs.createWriteStream('copied.txt');rs.pipe(ws);//默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数：readable.pipe(writable, &#123; end: false &#125;);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git fetch & pull 详解]]></title>
    <url>%2F2017%2F12%2F26%2Fgit-fetch%E5%92%8Cpull%2F</url>
    <content type="text"><![CDATA[1.简单概括先用一张图来理一下git fetch和git pull的概念： 可以简单的概括为： git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。 下面我们来详细了解一下git fetch 和git pull 的用法。 2.分支的概念在介绍两种方法之前，我们需要先了解一下分支的概念：分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。 如下图所示，当前有2个分支，A,C,E属于master分支，而A,B,D,F属于dev分支。 123A----C----E（master） \ B---D---F(dev) 它们的head指针分别指向E和F，对上述做如下操作： 12git checkout master //选择or切换到master分支git merge dev //将dev分支合并到当前分支(master)中 合并完成后： 123A---C---E---G(master) \ / B---D---F（dev） 现在A,B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而ABDF依然属于dev分支。可以继续在dev的分支上进行开发: 123A---C---E---G---H(master) \ / B---D---F---I（dev） 分支（branch）的基本操作： 123456789101112131415161718192021222324252627282930313233343536373839404142git branch //查看本地所有分支 git branch -r //查看远程所有分支git branch -a //查看本地和远程的所有分支git branch &lt;branchname&gt; //新建分支git branch -d &lt;branchname&gt; //删除本地分支git branch -d -r &lt;branchname&gt; //删除远程分支，删除后还需推送到服务器git push origin:&lt;branchname&gt; //删除后推送至服务器git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; //重命名本地分支/***重命名远程分支：*1、删除远程待修改分支*2、push本地新分支到远程服务器*///git中一些选项解释:-d--delete：删除-D--delete --force的快捷键-f--force：强制-m--move：移动或重命名-M--move --force的快捷键-r--remote：远程-a--all：所有 3.git fetch 用法git fetch 命令：1$ git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地 如果只想取回特定分支的更新，可以指定分支名： 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格 最常见的命令如取回origin 主机的master 分支： 1$ git fetch origin master 取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1$ git log -p FETCH_HEAD 如图： 可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。 我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 4.git pull 用法前面提到，git pull 的过程可以理解为：12git fetch origin master //从远程主机的master分支拉取最新内容 git merge FETCH_HEAD //将拉取下来的最新内容合并到当前所在的分支中 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为： 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略： 1$ git pull origin next 5.参考文章阮一峰老师博客: Git远程操作详解简书: git中fetch和pull的区别CSDN: git branch用法总结，查看、新建、删除、重命名博客园: Git中pull对比fetch和merge]]></content>
      <categories>
        <category>Git/Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DigitalOcean学生优惠]]></title>
    <url>%2F2017%2F12%2F25%2FDigitalOcean%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0%2F</url>
    <content type="text"><![CDATA[前言:之前在教你用shadowsocks和vps科学上网中使用的VPS到期并且续费比较贵所以最近转用了DigitalOcean，由于Github提供50刀的学生优惠，所以基本上可以免费使用一年低配VPS，虽然比之前的稍微慢一点，但是是免费的呀！ 具体操作步骤如下： 在Github上申请成为学生账号（只需要有学生邮箱即可，一般大学都提供学生邮箱，例如博主就是在教务处申请的以edu.cn结尾的教育邮箱） 成为学生账号后，Github会给你一个education package，里面有一大堆优惠，其中就包括DigitalOcean的$50兑换码(以前是$100),复制这个兑换码 在DigitalOcean上创建一个账号 用Paypal支付$5以激活账号 在Billing中输入兑换码，这样你账户中就有$55了 接下来就是 开通VPS - 第一次登陆修改密码 - 配置shadowsocks 了，流程跟教你用shadowsocks和vps科学上网中一致，不过不需要升级Ubuntu，省去了麻烦的一步 开始科学上网吧！]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IM即时聊天室（二）: Socket.io + Node.js]]></title>
    <url>%2F2017%2F12%2F21%2FIM%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E4%BA%8C%EF%BC%89-Socket-io%2F</url>
    <content type="text"><![CDATA[前言在IM即时聊天室（一）中,我们了解了WebSocket的相关知识和基础API作为编写聊天室的基础。那么作为进阶篇，今天我们就来讲一讲Socket.io 1、什么是Socket.io？简单来说，Socket.io封装了WebSocket以及其他的一些协议，是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。 它包括了客户端的JavaScript和服务器端的Node.js并且实现了WebSocket的服务端代码。同时还有很强的兼容性，兼容各种浏览器以及移动设备。有了它，我们能更方便快捷地实现服务器端与客户端之间的实时通讯。 2、使用Socket.io（初始化）服务端搭建： 服务端我使用的是Node.js，安装的话就直接点左边的链接下载对应的安装包就好啦，Linux稍麻烦一点需要配置一下node和npm的全局执行环境，网上有很多的教程，在这里就不赘述了。 安装好Node.js后，创建一个文件夹作为项目文件夹，定位到刚建的文件夹下，输入npm install socket.io安装Socket.io 安装完成之后，可以看到文件夹下多了node_modules文件，里面全是刚下载的socket.io依赖包。 初始化服务端： 创建一个app.js文件作为服务端代码 1234567891011121314151617181920212223/*app.js*//*构建http服务*/var app = require('http').createServer()/*引入socket.io*/var io = require('socket.io')(app);/*定义监听端口，可以自定义，端口不要被占用*/var PORT = 8081;/*监听端口*/app.listen(PORT);/***监听客户端连接*io是我们定义的服务端的socket*回调函数里面的socket是本次连接的客户端socket*io与socket是一对多的关系*/io.on('connection', function (socket) &#123; /*所有的监听on，与发送emit都得写在连接里面，包括断开连接*/&#125;) 对比WebSocket服务端初始化代码： 12345678910111213141516171819// 导入WebSocket模块:const WebSocket = require('ws');// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化: 在3000端口上打开一个WebSocket Serverconst wss = new WebSocketServer(&#123; port: 3000&#125;);//监听connection事件wss.on('connection', function (ws)&#123; /** *监听客户端事件 *回调函数里面的socket是本次连接的客户端socket *io与socket是一对多的关系 */&#125;); WebSocket流程：导入Websocket模块 - 创建server - 在自定义端口创建实例 - 在该端口监听事件Socket.io流程： 导入http模块 - 创建HttpServer - 基于HttpServer创建Socket.io实例 - 在自定义端口监听事件 可以看到，Socket.io的服务端初始化代码和WebSocket相比，流程相近。那么Socket.io的优势在哪呢？ 1.Socket.IO已经具有众多强大功能的模块和扩展API 2.Socket.IO实现了实时、双向、基于事件的通讯机制,它解决了实时的通信问题，并统一了服务端与客户端的编程方式。启动了Socket以后，就像建立了一条客户端与服务端的管道，两边可以互通有无。 接下来是初始化客户端： 12345678/***客户端初始化非常简单*只需要创建一个实例并指向目标服务器，注意端口要与服务器端保持一致*/var socket = io('ws://localhost:8081');//WebSocket客户端初始化代码:var ws = new WebSocket("ws://localhost:3000"); 3、使用Scoket.io（API函数介绍）** 1、客户端部分： ** 客户端向服务器端发送消息例如客户端向服务端发送登录请求 12//login是自定义的事件，后面是带的信息socket.emit('login',&#123;username:uname&#125;) 监听服务端发来的信息 123socket.on('String',function(data)&#123; //...) 给除了自己以外的客户端广播消息 1socket.broadcast.emit ** 2、服务端部分： ** 监听客户端连接,回调函数会传递本次连接的socket，下面列出的函数都要写在这个函数里 123io.on('connection',function(socket)&#123; //...)); 给指定的客户端发送消息 1io.sockets.socket(socketid).emit('String', data); 给所有客户端广播消息 1io.sockets.emit('String',data); 给当前正在处理的socket的客户端发送消息 1socket.emit('String', data); 监听客户端发送的信息 123socket.on('String',function(data)&#123; //...));]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IM即时聊天室（一）：WebSocket]]></title>
    <url>%2F2017%2F12%2F18%2FIM%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AWebSocket%2F</url>
    <content type="text"><![CDATA[1、什么是WebSocket?它和Socket有什么关系？在网络中，两个程序（进程）需要全双工通信，即双方可以同时向对方发送消息，需要用到的就是Socket，它能够提供端对端通信。 具体的实现过程如下： 客户端：创建一个Socket实例，并且提供服务端的IP和端口，如：192.168.1.1:8081 服务端：创建另一个Socket并绑定本地端口进行监听，如：localhost:8081 两者约定的端口要相同 客户端对服务端进行请求连接，服务端接受后通知客户端，双方就建立了一个TCP连接 至此，客户端和服务端之间可以进行双向通信，并且无客户端和服务端之分，均为端对端通信，但是主流的IM还是采用服务端转发的方式进行消息传送。 WebSocket借鉴了socket的思想，为web应用程序的客户端和服务端之间提供了一种全双工通信机制（注意：在WebSocket中是有客户端和服务端之分的）。 不同于原生Socket的端到端直接通信，WebSocke采取的方式是让所有客户端连接服务端，服务器再将不同客户端发送给自己的消息进行转发或者广播。 2、Websocket的通信原理虽然WebSocket是一种新应用层协议，但既然是基于Web端的技术，就无法脱离HTTP而单独存在。但是它和HTTP最大的不同是: 1、WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样 2、WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信所以当我们构建一个WebSocket实例的时候，实际上过程是这样的： 客户端发送一个 http Get 请求报文，告诉服务端：我要将通信协议切换到WebSocket啦！发送的数据格式类似下面的内容： 12345678910111213GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13//该请求和普通的HTTP请求有几点不同：//GET请求的地址不是类似/path/，而是以ws://开头的地址；//请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；//Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；//Sec-WebSocket-Version指定了WebSocket的协议版本。 如果服务端支持WebSocket协议，那么服务端就会将自己的通信协议切换为WebSocket，同时回传给客户端一个状态码为101的响应报头，该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= 以上过程称之为WebSocket协议握手（WebSocket Protocol handshake），有点类似于TCP上次握手，实际上这个WebSocket也确实是基于我们刚才发起的http的TCP连接。 然后就可以通过WebSocket进行服务端和客户端之间的连接啦，其提供两种数据传输方式：文本数据和二进制数据。 WebSocket出现前，Web端的即时通讯方法(Comet)：长轮询：客户端首先给服务端发送一个请求，服务端收到该请求之后如果数据没有更新则并不立即返回，服务端阻塞请求的返回，直到数据发生了更新或者发生了连接超时，服务端返回数据之后客户端再次发送同样的请求基于流式数据传输的长连接：通常的做法是在页面中嵌入一个隐藏的iframe,然后让这个iframe的src属性指向我们请求的一个服务端地址，并且为了数据更新，我们将页面上数据更新操作封装为一个js函数，将函数名当做参数传递到这个地址当中。服务端收到请求后解析地址取出参数（客户端js函数调用名），每当有数据更新的时候，返回对客户端函数的调用，并且将要跟新的数据以js函数的参数填入到返回内容当中 4、WebScoket基本API服务端： 123456789101112131415161718192021222324252627// 导入WebSocket模块:const WebSocket = require('ws');// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化: 在3000端口上打开一个WebSocket Serverconst wss = new WebSocketServer(&#123; port: 3000&#125;);/***监听connection事件*回调函数里面的ws是本次连接的客户端socket*io与ws是一对多的关系*/wss.on('connection', function (ws) &#123; console.log(`[SERVER] connection()`); ws.on('message', function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); ws.send(`ECHO: $&#123;message&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;)&#125;); 客户端： 1234567891011var ws = new WebSocket("ws://localhost:3000");//建立连接 ws.onopen = function()&#123;ws.send(“Test!”); &#125;;//响应收到的信息 ws.onmessage = function(evt)&#123;console.log(evt.data);&#125;; //关闭连接ws.onclose = function(evt)&#123;console.log(“WebSocketClosed!”);&#125;;//出错 ws.onerror = function(evt)&#123;console.log(“WebSocketError!”);&#125;;//向服务端发送信息ws.send('xxx');]]></content>
      <categories>
        <category>前端</category>
        <category>前端-通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈BFC]]></title>
    <url>%2F2017%2F12%2F12%2F%E6%B5%85%E8%B0%88BFC%2F</url>
    <content type="text"><![CDATA[写在前面：本文是我在看了CSS：潜藏着的BFC、为什么这么多人讲不清楚 BFC两篇文章后做做出的关于CSS的总结，如有错误与不足，欢迎指正，不胜感激！ 一、什么是BFC（Block Formatting Context） 我们先来看BFC的定义：块级格式化上下文，指一个独立的块级渲染区域，该区域有一套渲染规则来约束块级盒子布局,浮动层元素可再次进行交互,且与区域外部无关。 那么BFC是如何产生的呢？查阅MDN可以看到，满足下列条件之一便会生成BFC: 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素的 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素，一般默认为visible display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 最好的方法应该是使用display：flow-root ，不过部分浏览器不支持。 二、BFC内部的渲染布局规则及功能 简单归纳如下： 1.内部元素会在垂直方向一个接一个地排列 2.垂直方向上，两相邻盒子的margin会发生合并 举一个简单的例子：1234567891011.father&#123; border: 1px solid; min-height: 100px; display: flow-root;&#125;.son&#123; border: 1px solid red; background-color: red; height: 10px; margin: 10px 0px;&#125; 首先创建一个父块，里面包含两个相同的子块，子块的margin设置为 10px 0px；那么理论上这两个子块中间的margin应该为10+10=20px，结果却只有10px； 当我们把下方的子块margin变为20px 0px时，理论上中的margin应该为10+20=30px；结果却只有20px； 1234567891011121314151617.father&#123; border: 1px solid; min-height: 100px; display: flow-root;&#125;.son&#123; border: 1px solid red; background-color: red; height: 10px; margin: 10px 0px;&#125;.son1&#123; border: 1px solid red; background-color: red; height: 10px; margin: 20px 0px;&#125; 造成这种现象的原因就是margin合并： 块的顶部外边距和底部外边距有时被组合(折叠)为单个外边距，其大小是组合到其中的最大外边距，这种行为称为外边距塌陷(margin collapsing)，有的地方翻译为外边距合并。只有普通文档流块框的垂直外边距会叠加。行内框、浮动框、绝对定位框之间的外边距不会叠加。空元素的上下margin也会叠加 通俗地来说，BFC内相邻两元素的margin会发生合并，并且合并为两者中较大的那一个。 但是在不同的BFC中的两个元素不会发生重叠，我们甚至可以用这一特性在日常页面中防止margin合并，如： 12345678910111213&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;div style="overflow:hidden;"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;.son&#123; border:1px solid red; margin : 10px 0px; min-height:10px; background-color: red;&#125; 此时这两个son块不会发生margin重叠： 3.BFC只管着直系子元素，直系子元素所管理的元素则管不到 让我想起了以前历史课上学的一句话“你的附庸的附庸不是你的附庸”，是什么意思呢，就是你的爸爸管着你，你的爷爷管着你的爸爸，但是你的爷爷不会管你，因为你的爸爸已经管着你了。 4.BFC中的子元素(包括浮动元素)不会超出BFC的范围 衍生功能：用 BFC 包住浮动元素参照饥人谷方老师的代码：http://js.jirengu.com/rozaxufetu/1/edit?html,css,output BFC有清除浮动的效果，但是不推荐这样清除浮动，因为会带来内部元素无法出父元素的副作用，清除浮动还是用.clearfix比较好。 5.BFC内部东西与外部不重合，可以用于不同组件间划清界限 衍生功能：用 float + div 做左右自适应布局，避免了侵占浮动元素参照饥人谷方老师的代码：http://js.jirengu.com/felikenuve/1/edit?html,css,output]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈一谈对象]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[别想太多，是JavaScript对象 = v = 不同于JAVA这类面向对象（Object-Oriented，OO）的语言，JavaScript没有类的概念。因此它的对象也与基于类的语言中的对象有所不同。 ECMA-262中把对象定义为：无序属性的集合，属性可以包含基本值、对象或者函数 简单点来说，JS中的对象就是指由若干键值对组成的无序数据类型的集合。一般用{...}来表示一个对象，用xxx : xxx的格式来申明变量以及赋值，并以,分隔开，最后一个键值对末尾不加,如下面的例子: 123456789101112131415var animal = &#123; type: "animal", age: null, roar_sound: null, roar: function()&#123; console.log(this.roar_sound); &#125;&#125;;animal.type; //"animal"animal['type'];//"animal"animal.age; //nullanimal['age']; //nullanimal.roar(); //null 这个例子创建了一个animal对象，我们可以用 animal.xxx 或者 animal[&#39;xxx&#39;]/animal[&quot;xxx&quot;] 的方式来访问该对象的某一值。 PS：若属性名需要包含特殊字符串时，则需要用&quot; &quot;/&#39; &#39;括起来，并且只能通过xxx[‘xxx’]的方式来访问该对象,如： 1234567var person = &#123;'first-name' : 'Tom','second-name' : 'Riddle'&#125;//仅能用以下方式访问对象person['first-name']; //"Tom"person['second-name'];//"Riddle" 给JS对象增加或删除属性：由于JS的对象是动态类型，所以我们可以自由的给对象增加或删除属性。 12345678var person = &#123;&#125;;person.name; //不存在,undefinedperson.name = "Tony";person.name; //"Tony"delete person.name; //不存在,undefined 判断一个属性是否存在于对象中：我们可以使用in来判断一个属性是否存在于对象中，例如： 1234567var person = &#123;name : 'Tom Riddle'age : 'infinity'&#125;'name' in person; //true'type' in person; //false 但是，通过这个方法来判别有个缺点，就是你无法知道这个属性是对象本身有的还是通过继承得到的。比如Person中有name属性，tony继承于person，于是tony也有了name属性，但这并不是他本身所自有的。 为了判断属性是否为对象所自有的，我们可以使用对象名.hasOwnProperty(&#39;属性名&#39;)的方法来判断： 12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 注：总结于廖雪峰老师的教程，高程上的Object.defineProperty( ); 暂时没看出用途，等写到了再回来填坑。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[教你用shadowsocks和vps科学上网]]></title>
    <url>%2F2017%2F11%2F30%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;写在前面：作为一个程序员，用正确的姿势科学上网是必备技能，以前需求量不大的时候都是用各种免费的VPN看看外网，但是最近各种软件陆续倒下，加上自己看外网教程、技术文档，上Flickr的需求越来越多，决定还是用shadowsocks+VPS自己搭一个梯子比较舒服。 话不多说，先上图： HD画质连接速度近4Mbps，阿爸很满意并且嫌弃的看了一眼校园网。 接下来给大家介绍一下整个搭建过程 VPS给大家推荐一款vps:openvzvps，国人弄的VPS网站：https://www.50vz.net/aff.php?aff=886上面有各种规格的VPS，最便宜的年付￥70，每月500G流量，看剧什么的应该够了。 付款成功后，你就拥有自己的vps啦，官网会发一封邮件给你，里面包含了VPS的IP和初始密码。 你也可以在 客户中心-虚拟服务器管理-我的虚拟服务器 里面你可以看到刚才购买的vps，默认装的是cent os ,不过我换了ubuntu，本教程也基于ubuntu。 所以推荐你点击重装系统，然后选择ubuntu，设置新密码，一定要记得这个密码，登陆服务器的时候会用到。大约1-3分钟，系统很快就会安装好。 SSH连接VPS您可以用以下工具来登陆您的VPS: Putty: http://api.ifdream.net/soft/putty.zip Xshell:http://api.ifdream.net/soft/Xshell.zip 随便用一种工具，输入你的VPS的IP地址，端口为默认端口，然后连接。接着以root的身份登录，并输入你的VPS密码，若没设置新密码则输入邮件里的初始密码。 第一次登录时，OpenVZVPS会让你设置一下你的私人端口，以提高安全性，以后登录的时候就用这个端口登录。 接下来OpenVZVPS会更新Ubuntu相关文件，在这里博主出现了卡顿现象，上网查解决方案发现是因为系统默认使用IPV6来连接网络，但是博主校园网并不支持IPV6… 解决方案是使用WinSCP登录服务器，找到gai.config这个文件地址为/etc/gai.conf，并且将第54行前面的#去掉，也就是取消注释，这样就是允许使用IPV4连接。 123将这一行: #precedence ::ffff:0:0/96 100变为: precedence ::ffff:0:0/96 100 等待ubuntu安装好后退出，用putty或Xshell再次登录VPS就好啦。 安装shadowsockes使用命令一条一条的输入，$ sudo可以不用输入，安装shadowsocks 1234$ sudo apt-get update$ sudo apt-get install python-gevent python-pip$ sudo pip install shadowsocks$ apt-get install python-m2crypto 配置Shadowsocks全部安装好后，就可以开始配置config了 创建shadowsocks.json文件 vi /etc/shadowsocks.json 使用vim语句创建并编辑shadowsocks.json ，对vim不熟的同学也可以使用WinSCP来手动创建一个并编辑。 修改shadowsocks.json 将password改为你的VPS密码，localport改为你之前设置的的私人端口，接着保存就好啦 12345678&#123; "server":"0.0.0.0", "server_port":8388, "local_port":1080, "password":"password", "timeout":600, "method":"aes-256-cfb"&#125; 运行Shadowsocks123$ su -ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 上面两行代码分别是开启和关闭shadowsocks服务，这里我们打开就好啦。至此服务端建设完毕。 接下来下载shadowsocks客户端： Windows：https://github.com/shadowsocks/shadowsocks-windowsAndroid：https://github.com/shadowsocks/shadowsocks-androidIOS：https://github.com/shadowsocks/ShadowsocksX-NG 安装好后，配置端口，IP地址，密码，选择加密方式（都跟shadowsocks.json一致即可） 然后就可以开心的科学上网啦~]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法的JavaScript实现]]></title>
    <url>%2F2017%2F11%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序什么时候最快当输入的数据已经是正序时: O(n)什么时候最慢当输入的数据是反序时: O(n²)冒泡排序动图演示JavaScript代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;———-快速排序 快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(n log n) ，且O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 快速排序动图演示JavaScript代码实现1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; //分区操作 var pivot = left, //设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 先写这两种吧。。算法好多都忘了要慢慢补了QAQ]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端笔记（安全）：XSS防护]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[来源：今日头条技术博客 原文链接：https://techblog.toutiao.com/2017/06/06/xss/]]></content>
      <categories>
        <category>前端</category>
        <category>前端-Web安全防护</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端笔记（前端框架）：Bootstrap环境配置]]></title>
    <url>%2F2017%2F11%2F01%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%EF%BC%88%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%EF%BC%89-Bootstrap%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、下载相关生产环境文件 分别到：http://v3.bootcss.com/getting-started/#download http://jquery.com/download/下载最新的Bootstrap、jQuery生产环境文件，因为Bootstrap.js依赖于jQuery.js。 如果觉得麻烦也可以直接到我的CSDN文件下载：http://download.csdn.net/download/qq_36113598/10048235 下载完以后应该包括以下文件： 2、在&lt; head&gt;&lt; /head&gt;中引入Bootstrap.css并定义相应的meta信息： 12345678910111213&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Bootstrap Theme&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt;&lt;/head&gt; 其中&lt; meta name = “viewport” content =”XXX “&gt;有以下几个参数可以填写： width=device-width , &nbsp;&nbsp;&nbsp;设置页面为自适应 initial-scale = 1.0 , &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确保页面1：1呈现 shrink-to-fit = no , &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决IOS9的一些BUG 还可以设置：maximum-scale = 1.0 , user-scalable = no 禁止页面缩放，使WEBapp看起来更像原生应用。 3、在body中引入jQuery和Bootstrap.js，一般在body尾引入，方便阅读： 123&lt;!-- Bootstrap core JavaScript --&gt;&lt;script src="jquery/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; 完成上面三步以后，一个完整的Bootstrap环境就搭建好啦，开始设计自己的响应式网站吧！]]></content>
      <categories>
        <category>前端</category>
        <category>前端-前端框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端笔记（CSS）：CSS的覆盖]]></title>
    <url>%2F2017%2F10%2F29%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%EF%BC%88CSS%EF%BC%89%EF%BC%9ACSS%E7%9A%84%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[在页面中，我们常用id、class以及内联样式表来设置我们的组件CSS。有时候我们为了编码的简便会使用CSS库，这些库会设置好全局的CSS，但是有某几个组件我们不想使用CSS库中定义的样式而想用别的特别的样式怎么办呢？ 解决方法就是：使用自定的CSS样式覆盖之前的CSS样式 CSS中的优先级大体是：内联样式&gt;id引用&gt;class、伪类、属性选择器引用&gt;类型选择器、伪元素选择器引用，当优先类型相同时，数量较多的属性优先级较高。 特殊性排行：12345678910//选择器 类型(由低到高)style="" 1,0,0,0#test1 #test2 &#123;&#125; 0,2,0,0#content .date &#123;&#125; 0,1,1,0div#content &#123;&#125; 0,1,0,1#content &#123;&#125; 0,1,0,0p.comment .date &#123;&#125; 0,0,2,1p.comment &#123;&#125; 0,0,1,1div p &#123;&#125; 0,0,0,2p &#123;&#125; 0,0,0,1 举个例子，比如下面这个style： &lt; style&gt; body { background-color: black; font-family: Monospace; color: green; } #orange-text { color: orange; } .class1 { color: pink ; } .class2 { color: blue; } &lt; /style&gt; 我们来创建一个段落加上点文本看看字体颜色会发生什么变化 &lt;p&gt;Hello World!&lt;/p&gt;，首先不指定id和class，字体默认为body中的样式，为green class需要特别讲一下：比如这段代码&lt;p class=&quot;class1 class2&quot; &gt;Hello World!&lt;/p&gt;这段文本会同时继承class1、class2中的样式，但是当这两个类中有相同的变量时，class间有冲突时，优先使用后者的定义，所以此时文本字体为blue。 &lt;p class=&quot;class1 class2&quot; id=&quot;orange-text&quot;&gt;Hello World!&lt;/p&gt; 此时id覆盖class，文本字体为orange。 &lt;p class=&quot;class1 class2&quot; id=&quot;orange-text&quot; style=&quot;color:whitle&quot;&gt;Hello World!&lt;/p&gt; 此时内联样式表覆盖id和class，文本字体为white。 如果你想某个样式的某个变量不被覆盖的话，可以在其后面加上！important来强制增加其的优先级，但是只能加在id、class中。比如在#orange-text中的color后面加上！important： #orange-text { color: orange ！important ; } &lt;p class=&quot;class1 class2&quot; id=&quot;orange-text&quot; style=&quot;color:whitle&quot;&gt;Hello World!&lt;/p&gt; 这样的话就算有内联样式表设置color为white，color仍然为orange。 当优先类型相同时，数量较多的属性优先级较高，比如：12345678910#test1 #test2 &#123; color:red;&#125;div #test2&#123; color:black;&#125;&lt;div id="test1"&gt;&lt;h1 id="test2"&gt;Test&lt;/h1&gt;&lt;/div&gt; 页面中的h1应为红色，因为red属性有两个id，而black属性只有一个id选择器和一个类型选择器。]]></content>
      <categories>
        <category>前端</category>
        <category>前端-CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows下用Git/Github托管代码]]></title>
    <url>%2F2017%2F10%2F02%2FWindows%E4%B8%8B%E7%94%A8Git-Github%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[写在前面 : 摘自第一行代码，仅用作学习 一、访问 : https://git-for-windows.github.io/ 下载git for windows 二、打开Git Bash配置下身份： 12git config --global user.name "Tony"git config --golbal user.email "tony@gmail.com" 验证是否创建成功：仅需将用户名和邮箱去掉12git config --global user.name git config --golbal user.email 若创建成功则会打印出刚才创建的用户名和邮箱 三、创建代码仓库 进入到项目文件夹： 1cd 项目文件夹位置 在这个目录下输入命令： 1git init 仓库创建完成后会在项目文件夹下生成一个隐藏的.Git文件夹，用于记录本地所有Git操作，可以通过ls -al命令来查看，如果想删除本地仓库直接删除这个隐藏文件夹就好了 四、提交本地代码 添加想要提交的某个文件/某个目录/全部文件分别对应： 1git add 文件名 / git add 目录名 / git add . 提交文件： 1git commit -m "first commit." 后面的描述信息可以任意更改，但一定要有。 五、创建和选择分支 创建：git branch 分支名 选择分支：git checkout 分支名 将分支一的代码合并到主支上： 12git checkout mastergit merge 分支一 删除分支：git branch -D 分支名 六、将代码托管到Github上 在github上创建完项目后，用Git Bush进入到本地的文件夹，init以后，将github上的项目克隆到本地： 1git clone guihub地址 将克隆下来的.gitgnore、LICENSE、README.md、.git这四个文件放到本项目文件夹中，覆盖原有项目。 接着提交就好了： 123git add .git commit -m "First conmit."git push origin master]]></content>
      <categories>
        <category>Git/Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android端用JDBC远程连接服务端Mysql数据库]]></title>
    <url>%2F2017%2F09%2F14%2FAndroid%E7%AB%AF%E7%94%A8JDBC%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AFMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[转自：http://blog.csdn.net/yuanzeyao/article/details/38777557 在学习android连接Mysql 数据库前，我们先来复习一下java如何通过jdbc连接MysqlJDBC程序开发的几个步骤: 0、在工程的libs文件夹下放置jar包按照：Project Structure — Denpendencies — + — Jar dependency 的步骤导入jar包到工程里jar包下载地址：http://download.csdn.net/download/qq_36113598/9979455 1、注册驱动程序 Class.forName(“com.mysql.jdbc.Driver”); JAVA规范中明确规定：所有的驱动程序必须在静态初始化代码块中将驱动注册到驱动程序管理器中。 2、建立数据库连接对象(Connection) Connection conn=DriverManager.getConnection(“jdbc:mysql://192.168.8.21:3306/test”, ” User”,” Pasword”); 3、创建Statement对象 Statement stm = con.createStatement(); 4、发送SQL语句 stm.executeUpdate()或者stm.executeQuery() 5、如果有结果集，处理结果集(ResultSet) 6、关闭相应的流资源 那么开始在android中开始通过Jdbc连接Mysql数据库吧 12345678910111213141516171819202122232425262728293031323334353637public void onClickQuery(View view) &#123; //在android中操作数据库最好在子线程中执行，否则可能会报异常 new Thread() &#123; public void run() &#123; try &#123; //注册驱动 Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://10.0.2.2:3306/gjun"; Connection conn = DriverManager.getConnection(url, "root", "gavin"); Statement stmt = conn.createStatement(); String sql = "select * from t_user"; ResultSet rs = stmt.executeQuery(sql); while (rs.next()) &#123; //处理结果集 &#125; rs.close(); stmt.close(); conn.close(); Log.v("final", "success to connect!"); &#125; catch(ClassNotFoundException e) &#123; Log.v("final", "fail to connect!"+" "+e.getMessage()); &#125; catch (SQLException e) &#123; Log.v("final", "fail to connect!"+" "+e.getMessage()); &#125; &#125;; &#125;.start();&#125; 注意，我是在模拟器上运行的，如果在真机上运行，那么Ip地址就需要换成真实Ip地址，在虚拟机中，10.0.2.2指的就是寄主电脑的Ip地址 在运行过程中一定要注意： 1、关闭本机防火墙(不一定需要) 2、在Manifest中加入网络访问权限android.permission.INTERNET 3、服务端mysql数据库允许外部远程用户访问]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用OkHttp]]></title>
    <url>%2F2017%2F09%2F08%2F%E4%BD%BF%E7%94%A8OkHttp%2F</url>
    <content type="text"><![CDATA[写在最前面：用于个人学习，资料来源于《第一行代码》（郭霖 著）和 OkHttp教程 1. 首先添加OkHttp库的依赖在app/build.gradle里的dependencies闭包里加入最新版本的okhttp依赖 12345dependencies &#123; ...(省略部分) compile 'com.squareup.okhttp3:okhttp:3.7.0' ...&#125; 或者在File-Project Structure-app-denpendencies里从网上导入相应的依赖 2. 创建一个OkHttp实例1OkHttpClient client = new OkHttpClient(); 3. 创建一个Request对象123Request request = new Request.Builder().url("网址") //或者调用String变量.build(); 4.调用同步/异步方法来发送请求并获取服务器返回数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//同步方法:Response response = client.newcall(request).execute();//异步方法:client.newCall(request).enqueue(callback); //callback即为返回数据载体//完整代码(同步)： private void sendRequestWithOkHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("网址") .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; //完整代码(异步)：private void sendRequestWithOkHttp(okhttp3.Callback callback)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("网址") .build(); client.newCall(request).enqueue(callback); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;//在调用的时候要重写两个方法：sendRequestWithOkHttp( new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //do &#125;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; final String responseText =zresponse.body().string(); //返回的json数据 &#125; &#125;)]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用Gson解析Json数据的一些知识储备]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%88%A9%E7%94%A8Gson%E8%A7%A3%E6%9E%90Json%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1、利用GsonFormat直接创建JSON语句对应的JavaBean 2、由于JSON语句里不能使用大写解析出的JavaBean变量名全为小写，而有时我们需要将部分变量名改为大写或其他名字，可使用如下方法： 123@SerializedName("n")private String userName; //将Json传回来的n更改为userName； 3、使用Gson解析Json语句，生成实体类（比如下面的News类） 1234public static News parseJsonWithGson(final String requestText)&#123; Gson gson = new Gson(); return gson.fromJson(requestText, News.class); &#125; 调用这个方法以后就会生成Json对应的JavaBean了，接下来就可以愉快的调用里面的参数啦，当然前提是要导入了Gson的包，如：compile ‘com.google.code.gson:gson:2.8.0’，最新的依赖包请执行查询。 4、完整流程展示： 首先，从api获取Json数据如下： 然后，用Gsonformat解析出对应的JavaBean： 接着调用Gson，生成对应实体： 12final NList nlist = Utility.parseJsonWithGsonN(responseText); //用Gson处理javaon数据，并传回NewsList实例中 最后根据JavaBean的结构愉快地调用nlist里面的内容就好啦~]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
